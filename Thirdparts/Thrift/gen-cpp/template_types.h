/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef template_TYPES_H
#define template_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/TBase.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace CytxGame {

class PlayerAttrConfig;

class MagicPlayerAttrConfig;

class CreatureAttrConfig;

class CreatureAttrConfigTable;

class PetAttrConfig;

class PetAttrConfigTable;

class DungeonConfig;

class DungeonConfigTable;

class ChildDungeonConfig;

class TriggerConfig;

class TriggerConfigTable;

class ItemConfig;

class ItemConfigTable;

class BulletConfig;

class BulletConfigTable;

class SoundPath;

class SoundPathMap;

class ItemGeneratorConfig;

class ItemGeneratorConfigTable;

class VersionConfig;

typedef struct _PlayerAttrConfig__isset {
  _PlayerAttrConfig__isset() : initHp(false), maxHp(false), moveSpeed(false), jumpSpeed(false), guardDuration(false) {}
  bool initHp :1;
  bool maxHp :1;
  bool moveSpeed :1;
  bool jumpSpeed :1;
  bool guardDuration :1;
} _PlayerAttrConfig__isset;

class PlayerAttrConfig : public virtual ::apache::thrift::TBase {
 public:

  PlayerAttrConfig(const PlayerAttrConfig&);
  PlayerAttrConfig& operator=(const PlayerAttrConfig&);
  PlayerAttrConfig() : initHp(0), maxHp(0), moveSpeed(0), jumpSpeed(0), guardDuration(0) {
  }

  virtual ~PlayerAttrConfig() throw();
  int32_t initHp;
  int32_t maxHp;
  int32_t moveSpeed;
  int32_t jumpSpeed;
  int32_t guardDuration;

  _PlayerAttrConfig__isset __isset;

  void __set_initHp(const int32_t val);

  void __set_maxHp(const int32_t val);

  void __set_moveSpeed(const int32_t val);

  void __set_jumpSpeed(const int32_t val);

  void __set_guardDuration(const int32_t val);

  bool operator == (const PlayerAttrConfig & rhs) const
  {
    if (!(initHp == rhs.initHp))
      return false;
    if (!(maxHp == rhs.maxHp))
      return false;
    if (!(moveSpeed == rhs.moveSpeed))
      return false;
    if (!(jumpSpeed == rhs.jumpSpeed))
      return false;
    if (!(guardDuration == rhs.guardDuration))
      return false;
    return true;
  }
  bool operator != (const PlayerAttrConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PlayerAttrConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PlayerAttrConfig &a, PlayerAttrConfig &b);

inline std::ostream& operator<<(std::ostream& out, const PlayerAttrConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _MagicPlayerAttrConfig__isset {
  _MagicPlayerAttrConfig__isset() : initMana(false), maxMana(false), initChopCost(false), ChopCostAdd(false), maxChopCost(false), blowCost(false), minFogRadius(false), maxFogRadius(false), manaTimer(false), winduration(false), isFireMode(false), blowCdTime(false) {}
  bool initMana :1;
  bool maxMana :1;
  bool initChopCost :1;
  bool ChopCostAdd :1;
  bool maxChopCost :1;
  bool blowCost :1;
  bool minFogRadius :1;
  bool maxFogRadius :1;
  bool manaTimer :1;
  bool winduration :1;
  bool isFireMode :1;
  bool blowCdTime :1;
} _MagicPlayerAttrConfig__isset;

class MagicPlayerAttrConfig : public virtual ::apache::thrift::TBase {
 public:

  MagicPlayerAttrConfig(const MagicPlayerAttrConfig&);
  MagicPlayerAttrConfig& operator=(const MagicPlayerAttrConfig&);
  MagicPlayerAttrConfig() : initMana(0), maxMana(0), initChopCost(0), ChopCostAdd(0), maxChopCost(0), blowCost(0), minFogRadius(0), maxFogRadius(0), manaTimer(0), winduration(0), isFireMode(0), blowCdTime(0) {
  }

  virtual ~MagicPlayerAttrConfig() throw();
  int32_t initMana;
  int32_t maxMana;
  int32_t initChopCost;
  int32_t ChopCostAdd;
  int32_t maxChopCost;
  int32_t blowCost;
  int32_t minFogRadius;
  int32_t maxFogRadius;
  int32_t manaTimer;
  int32_t winduration;
  bool isFireMode;
  int32_t blowCdTime;

  _MagicPlayerAttrConfig__isset __isset;

  void __set_initMana(const int32_t val);

  void __set_maxMana(const int32_t val);

  void __set_initChopCost(const int32_t val);

  void __set_ChopCostAdd(const int32_t val);

  void __set_maxChopCost(const int32_t val);

  void __set_blowCost(const int32_t val);

  void __set_minFogRadius(const int32_t val);

  void __set_maxFogRadius(const int32_t val);

  void __set_manaTimer(const int32_t val);

  void __set_winduration(const int32_t val);

  void __set_isFireMode(const bool val);

  void __set_blowCdTime(const int32_t val);

  bool operator == (const MagicPlayerAttrConfig & rhs) const
  {
    if (!(initMana == rhs.initMana))
      return false;
    if (!(maxMana == rhs.maxMana))
      return false;
    if (!(initChopCost == rhs.initChopCost))
      return false;
    if (!(ChopCostAdd == rhs.ChopCostAdd))
      return false;
    if (!(maxChopCost == rhs.maxChopCost))
      return false;
    if (!(blowCost == rhs.blowCost))
      return false;
    if (!(minFogRadius == rhs.minFogRadius))
      return false;
    if (!(maxFogRadius == rhs.maxFogRadius))
      return false;
    if (!(manaTimer == rhs.manaTimer))
      return false;
    if (!(winduration == rhs.winduration))
      return false;
    if (!(isFireMode == rhs.isFireMode))
      return false;
    if (!(blowCdTime == rhs.blowCdTime))
      return false;
    return true;
  }
  bool operator != (const MagicPlayerAttrConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const MagicPlayerAttrConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(MagicPlayerAttrConfig &a, MagicPlayerAttrConfig &b);

inline std::ostream& operator<<(std::ostream& out, const MagicPlayerAttrConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CreatureAttrConfig__isset {
  _CreatureAttrConfig__isset() : id(false), name(false), type(false), initHp(false), maxHp(false), patrolSpeed(false), chaseSpeed(false), attackSpeed(false), guardArea(false), attackArea(false), aiMode(false), assetBundle(false), sourceName(false), bonusStrategy(false) {}
  bool id :1;
  bool name :1;
  bool type :1;
  bool initHp :1;
  bool maxHp :1;
  bool patrolSpeed :1;
  bool chaseSpeed :1;
  bool attackSpeed :1;
  bool guardArea :1;
  bool attackArea :1;
  bool aiMode :1;
  bool assetBundle :1;
  bool sourceName :1;
  bool bonusStrategy :1;
} _CreatureAttrConfig__isset;

class CreatureAttrConfig : public virtual ::apache::thrift::TBase {
 public:

  CreatureAttrConfig(const CreatureAttrConfig&);
  CreatureAttrConfig& operator=(const CreatureAttrConfig&);
  CreatureAttrConfig() : id(0), name(), type(0), initHp(0), maxHp(0), patrolSpeed(0), chaseSpeed(0), attackSpeed(0), guardArea(0), attackArea(0), aiMode(0), assetBundle(), sourceName(), bonusStrategy(0) {
  }

  virtual ~CreatureAttrConfig() throw();
  int32_t id;
  std::string name;
  int32_t type;
  int32_t initHp;
  int32_t maxHp;
  int32_t patrolSpeed;
  int32_t chaseSpeed;
  int32_t attackSpeed;
  int32_t guardArea;
  int32_t attackArea;
  int32_t aiMode;
  std::string assetBundle;
  std::string sourceName;
  int32_t bonusStrategy;

  _CreatureAttrConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_name(const std::string& val);

  void __set_type(const int32_t val);

  void __set_initHp(const int32_t val);

  void __set_maxHp(const int32_t val);

  void __set_patrolSpeed(const int32_t val);

  void __set_chaseSpeed(const int32_t val);

  void __set_attackSpeed(const int32_t val);

  void __set_guardArea(const int32_t val);

  void __set_attackArea(const int32_t val);

  void __set_aiMode(const int32_t val);

  void __set_assetBundle(const std::string& val);

  void __set_sourceName(const std::string& val);

  void __set_bonusStrategy(const int32_t val);

  bool operator == (const CreatureAttrConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(initHp == rhs.initHp))
      return false;
    if (!(maxHp == rhs.maxHp))
      return false;
    if (!(patrolSpeed == rhs.patrolSpeed))
      return false;
    if (!(chaseSpeed == rhs.chaseSpeed))
      return false;
    if (!(attackSpeed == rhs.attackSpeed))
      return false;
    if (!(guardArea == rhs.guardArea))
      return false;
    if (!(attackArea == rhs.attackArea))
      return false;
    if (!(aiMode == rhs.aiMode))
      return false;
    if (!(assetBundle == rhs.assetBundle))
      return false;
    if (!(sourceName == rhs.sourceName))
      return false;
    if (!(bonusStrategy == rhs.bonusStrategy))
      return false;
    return true;
  }
  bool operator != (const CreatureAttrConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreatureAttrConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreatureAttrConfig &a, CreatureAttrConfig &b);

inline std::ostream& operator<<(std::ostream& out, const CreatureAttrConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CreatureAttrConfigTable__isset {
  _CreatureAttrConfigTable__isset() : creatureConfigMap(false) {}
  bool creatureConfigMap :1;
} _CreatureAttrConfigTable__isset;

class CreatureAttrConfigTable : public virtual ::apache::thrift::TBase {
 public:

  CreatureAttrConfigTable(const CreatureAttrConfigTable&);
  CreatureAttrConfigTable& operator=(const CreatureAttrConfigTable&);
  CreatureAttrConfigTable() {
  }

  virtual ~CreatureAttrConfigTable() throw();
  std::map<int32_t, CreatureAttrConfig>  creatureConfigMap;

  _CreatureAttrConfigTable__isset __isset;

  void __set_creatureConfigMap(const std::map<int32_t, CreatureAttrConfig> & val);

  bool operator == (const CreatureAttrConfigTable & rhs) const
  {
    if (!(creatureConfigMap == rhs.creatureConfigMap))
      return false;
    return true;
  }
  bool operator != (const CreatureAttrConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CreatureAttrConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CreatureAttrConfigTable &a, CreatureAttrConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const CreatureAttrConfigTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PetAttrConfig__isset {
  _PetAttrConfig__isset() : id(false), name(false), type(false), initHp(false), maxHp(false), aiMode(false), assetBundle(false), sourceName(false), fellowSpeed(false), chaseSpeed(false), attackSpeed(false) {}
  bool id :1;
  bool name :1;
  bool type :1;
  bool initHp :1;
  bool maxHp :1;
  bool aiMode :1;
  bool assetBundle :1;
  bool sourceName :1;
  bool fellowSpeed :1;
  bool chaseSpeed :1;
  bool attackSpeed :1;
} _PetAttrConfig__isset;

class PetAttrConfig : public virtual ::apache::thrift::TBase {
 public:

  PetAttrConfig(const PetAttrConfig&);
  PetAttrConfig& operator=(const PetAttrConfig&);
  PetAttrConfig() : id(0), name(), type(0), initHp(0), maxHp(0), aiMode(0), assetBundle(), sourceName(), fellowSpeed(0), chaseSpeed(0), attackSpeed(0) {
  }

  virtual ~PetAttrConfig() throw();
  int32_t id;
  std::string name;
  int32_t type;
  int32_t initHp;
  int32_t maxHp;
  int32_t aiMode;
  std::string assetBundle;
  std::string sourceName;
  int32_t fellowSpeed;
  int32_t chaseSpeed;
  int32_t attackSpeed;

  _PetAttrConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_name(const std::string& val);

  void __set_type(const int32_t val);

  void __set_initHp(const int32_t val);

  void __set_maxHp(const int32_t val);

  void __set_aiMode(const int32_t val);

  void __set_assetBundle(const std::string& val);

  void __set_sourceName(const std::string& val);

  void __set_fellowSpeed(const int32_t val);

  void __set_chaseSpeed(const int32_t val);

  void __set_attackSpeed(const int32_t val);

  bool operator == (const PetAttrConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(initHp == rhs.initHp))
      return false;
    if (!(maxHp == rhs.maxHp))
      return false;
    if (!(aiMode == rhs.aiMode))
      return false;
    if (!(assetBundle == rhs.assetBundle))
      return false;
    if (!(sourceName == rhs.sourceName))
      return false;
    if (!(fellowSpeed == rhs.fellowSpeed))
      return false;
    if (!(chaseSpeed == rhs.chaseSpeed))
      return false;
    if (!(attackSpeed == rhs.attackSpeed))
      return false;
    return true;
  }
  bool operator != (const PetAttrConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PetAttrConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PetAttrConfig &a, PetAttrConfig &b);

inline std::ostream& operator<<(std::ostream& out, const PetAttrConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _PetAttrConfigTable__isset {
  _PetAttrConfigTable__isset() : petConfigMap(false) {}
  bool petConfigMap :1;
} _PetAttrConfigTable__isset;

class PetAttrConfigTable : public virtual ::apache::thrift::TBase {
 public:

  PetAttrConfigTable(const PetAttrConfigTable&);
  PetAttrConfigTable& operator=(const PetAttrConfigTable&);
  PetAttrConfigTable() {
  }

  virtual ~PetAttrConfigTable() throw();
  std::map<int32_t, PetAttrConfig>  petConfigMap;

  _PetAttrConfigTable__isset __isset;

  void __set_petConfigMap(const std::map<int32_t, PetAttrConfig> & val);

  bool operator == (const PetAttrConfigTable & rhs) const
  {
    if (!(petConfigMap == rhs.petConfigMap))
      return false;
    return true;
  }
  bool operator != (const PetAttrConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const PetAttrConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(PetAttrConfigTable &a, PetAttrConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const PetAttrConfigTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DungeonConfig__isset {
  _DungeonConfig__isset() : id(false), name(false), icon(false), mapName(false), childrenList(false) {}
  bool id :1;
  bool name :1;
  bool icon :1;
  bool mapName :1;
  bool childrenList :1;
} _DungeonConfig__isset;

class DungeonConfig : public virtual ::apache::thrift::TBase {
 public:

  DungeonConfig(const DungeonConfig&);
  DungeonConfig& operator=(const DungeonConfig&);
  DungeonConfig() : id(0), name(), icon(), mapName() {
  }

  virtual ~DungeonConfig() throw();
  int32_t id;
  std::string name;
  std::string icon;
  std::string mapName;
  std::vector<ChildDungeonConfig>  childrenList;

  _DungeonConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_name(const std::string& val);

  void __set_icon(const std::string& val);

  void __set_mapName(const std::string& val);

  void __set_childrenList(const std::vector<ChildDungeonConfig> & val);

  bool operator == (const DungeonConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(icon == rhs.icon))
      return false;
    if (!(mapName == rhs.mapName))
      return false;
    if (!(childrenList == rhs.childrenList))
      return false;
    return true;
  }
  bool operator != (const DungeonConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DungeonConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DungeonConfig &a, DungeonConfig &b);

inline std::ostream& operator<<(std::ostream& out, const DungeonConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DungeonConfigTable__isset {
  _DungeonConfigTable__isset() : dungeonConfigMap(false) {}
  bool dungeonConfigMap :1;
} _DungeonConfigTable__isset;

class DungeonConfigTable : public virtual ::apache::thrift::TBase {
 public:

  DungeonConfigTable(const DungeonConfigTable&);
  DungeonConfigTable& operator=(const DungeonConfigTable&);
  DungeonConfigTable() {
  }

  virtual ~DungeonConfigTable() throw();
  std::map<int32_t, DungeonConfig>  dungeonConfigMap;

  _DungeonConfigTable__isset __isset;

  void __set_dungeonConfigMap(const std::map<int32_t, DungeonConfig> & val);

  bool operator == (const DungeonConfigTable & rhs) const
  {
    if (!(dungeonConfigMap == rhs.dungeonConfigMap))
      return false;
    return true;
  }
  bool operator != (const DungeonConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DungeonConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DungeonConfigTable &a, DungeonConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const DungeonConfigTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ChildDungeonConfig__isset {
  _ChildDungeonConfig__isset() : id(false), name(false), resourceName(false) {}
  bool id :1;
  bool name :1;
  bool resourceName :1;
} _ChildDungeonConfig__isset;

class ChildDungeonConfig : public virtual ::apache::thrift::TBase {
 public:

  ChildDungeonConfig(const ChildDungeonConfig&);
  ChildDungeonConfig& operator=(const ChildDungeonConfig&);
  ChildDungeonConfig() : id(0), name(), resourceName() {
  }

  virtual ~ChildDungeonConfig() throw();
  int32_t id;
  std::string name;
  std::string resourceName;

  _ChildDungeonConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_name(const std::string& val);

  void __set_resourceName(const std::string& val);

  bool operator == (const ChildDungeonConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(resourceName == rhs.resourceName))
      return false;
    return true;
  }
  bool operator != (const ChildDungeonConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ChildDungeonConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ChildDungeonConfig &a, ChildDungeonConfig &b);

inline std::ostream& operator<<(std::ostream& out, const ChildDungeonConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TriggerConfig__isset {
  _TriggerConfig__isset() : id(false), name(false), type(false), assetBundle(false), sourceName(false), bonusStrategy(false) {}
  bool id :1;
  bool name :1;
  bool type :1;
  bool assetBundle :1;
  bool sourceName :1;
  bool bonusStrategy :1;
} _TriggerConfig__isset;

class TriggerConfig : public virtual ::apache::thrift::TBase {
 public:

  TriggerConfig(const TriggerConfig&);
  TriggerConfig& operator=(const TriggerConfig&);
  TriggerConfig() : id(0), name(), type(0), assetBundle(), sourceName(), bonusStrategy(0) {
  }

  virtual ~TriggerConfig() throw();
  int32_t id;
  std::string name;
  int32_t type;
  std::string assetBundle;
  std::string sourceName;
  int32_t bonusStrategy;

  _TriggerConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_name(const std::string& val);

  void __set_type(const int32_t val);

  void __set_assetBundle(const std::string& val);

  void __set_sourceName(const std::string& val);

  void __set_bonusStrategy(const int32_t val);

  bool operator == (const TriggerConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(assetBundle == rhs.assetBundle))
      return false;
    if (!(sourceName == rhs.sourceName))
      return false;
    if (!(bonusStrategy == rhs.bonusStrategy))
      return false;
    return true;
  }
  bool operator != (const TriggerConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TriggerConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TriggerConfig &a, TriggerConfig &b);

inline std::ostream& operator<<(std::ostream& out, const TriggerConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TriggerConfigTable__isset {
  _TriggerConfigTable__isset() : triggerConfigMap(false) {}
  bool triggerConfigMap :1;
} _TriggerConfigTable__isset;

class TriggerConfigTable : public virtual ::apache::thrift::TBase {
 public:

  TriggerConfigTable(const TriggerConfigTable&);
  TriggerConfigTable& operator=(const TriggerConfigTable&);
  TriggerConfigTable() {
  }

  virtual ~TriggerConfigTable() throw();
  std::map<int32_t, TriggerConfig>  triggerConfigMap;

  _TriggerConfigTable__isset __isset;

  void __set_triggerConfigMap(const std::map<int32_t, TriggerConfig> & val);

  bool operator == (const TriggerConfigTable & rhs) const
  {
    if (!(triggerConfigMap == rhs.triggerConfigMap))
      return false;
    return true;
  }
  bool operator != (const TriggerConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TriggerConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TriggerConfigTable &a, TriggerConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const TriggerConfigTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ItemConfig__isset {
  _ItemConfig__isset() : id(false), name(false), type(false), blood(false), mana(false), light(false), dataPrefab(false), assetBundle(false), sourceName(false), dieEffect(false) {}
  bool id :1;
  bool name :1;
  bool type :1;
  bool blood :1;
  bool mana :1;
  bool light :1;
  bool dataPrefab :1;
  bool assetBundle :1;
  bool sourceName :1;
  bool dieEffect :1;
} _ItemConfig__isset;

class ItemConfig : public virtual ::apache::thrift::TBase {
 public:

  ItemConfig(const ItemConfig&);
  ItemConfig& operator=(const ItemConfig&);
  ItemConfig() : id(0), name(), type(0), blood(0), mana(0), light(0), dataPrefab(), assetBundle(), sourceName(), dieEffect() {
  }

  virtual ~ItemConfig() throw();
  int32_t id;
  std::string name;
  int32_t type;
  int32_t blood;
  int32_t mana;
  int32_t light;
  std::string dataPrefab;
  std::string assetBundle;
  std::string sourceName;
  std::string dieEffect;

  _ItemConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_name(const std::string& val);

  void __set_type(const int32_t val);

  void __set_blood(const int32_t val);

  void __set_mana(const int32_t val);

  void __set_light(const int32_t val);

  void __set_dataPrefab(const std::string& val);

  void __set_assetBundle(const std::string& val);

  void __set_sourceName(const std::string& val);

  void __set_dieEffect(const std::string& val);

  bool operator == (const ItemConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(blood == rhs.blood))
      return false;
    if (!(mana == rhs.mana))
      return false;
    if (!(light == rhs.light))
      return false;
    if (!(dataPrefab == rhs.dataPrefab))
      return false;
    if (!(assetBundle == rhs.assetBundle))
      return false;
    if (!(sourceName == rhs.sourceName))
      return false;
    if (!(dieEffect == rhs.dieEffect))
      return false;
    return true;
  }
  bool operator != (const ItemConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemConfig &a, ItemConfig &b);

inline std::ostream& operator<<(std::ostream& out, const ItemConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ItemConfigTable__isset {
  _ItemConfigTable__isset() : itemConfigMap(false) {}
  bool itemConfigMap :1;
} _ItemConfigTable__isset;

class ItemConfigTable : public virtual ::apache::thrift::TBase {
 public:

  ItemConfigTable(const ItemConfigTable&);
  ItemConfigTable& operator=(const ItemConfigTable&);
  ItemConfigTable() {
  }

  virtual ~ItemConfigTable() throw();
  std::map<int32_t, ItemConfig>  itemConfigMap;

  _ItemConfigTable__isset __isset;

  void __set_itemConfigMap(const std::map<int32_t, ItemConfig> & val);

  bool operator == (const ItemConfigTable & rhs) const
  {
    if (!(itemConfigMap == rhs.itemConfigMap))
      return false;
    return true;
  }
  bool operator != (const ItemConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemConfigTable &a, ItemConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const ItemConfigTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BulletConfig__isset {
  _BulletConfig__isset() : id(false), name(false), type(false), atk(false), manaCost(false), shootStrategy(false), sourceName(false), assetBundle(false), speed(false) {}
  bool id :1;
  bool name :1;
  bool type :1;
  bool atk :1;
  bool manaCost :1;
  bool shootStrategy :1;
  bool sourceName :1;
  bool assetBundle :1;
  bool speed :1;
} _BulletConfig__isset;

class BulletConfig : public virtual ::apache::thrift::TBase {
 public:

  BulletConfig(const BulletConfig&);
  BulletConfig& operator=(const BulletConfig&);
  BulletConfig() : id(0), name(), type(0), atk(0), manaCost(0), shootStrategy(0), sourceName(), assetBundle(), speed(0) {
  }

  virtual ~BulletConfig() throw();
  int32_t id;
  std::string name;
  int32_t type;
  int32_t atk;
  int32_t manaCost;
  int32_t shootStrategy;
  std::string sourceName;
  std::string assetBundle;
  double speed;

  _BulletConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_name(const std::string& val);

  void __set_type(const int32_t val);

  void __set_atk(const int32_t val);

  void __set_manaCost(const int32_t val);

  void __set_shootStrategy(const int32_t val);

  void __set_sourceName(const std::string& val);

  void __set_assetBundle(const std::string& val);

  void __set_speed(const double val);

  bool operator == (const BulletConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(atk == rhs.atk))
      return false;
    if (!(manaCost == rhs.manaCost))
      return false;
    if (!(shootStrategy == rhs.shootStrategy))
      return false;
    if (!(sourceName == rhs.sourceName))
      return false;
    if (!(assetBundle == rhs.assetBundle))
      return false;
    if (!(speed == rhs.speed))
      return false;
    return true;
  }
  bool operator != (const BulletConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BulletConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BulletConfig &a, BulletConfig &b);

inline std::ostream& operator<<(std::ostream& out, const BulletConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BulletConfigTable__isset {
  _BulletConfigTable__isset() : bulletConfigMap(false) {}
  bool bulletConfigMap :1;
} _BulletConfigTable__isset;

class BulletConfigTable : public virtual ::apache::thrift::TBase {
 public:

  BulletConfigTable(const BulletConfigTable&);
  BulletConfigTable& operator=(const BulletConfigTable&);
  BulletConfigTable() {
  }

  virtual ~BulletConfigTable() throw();
  std::map<int32_t, BulletConfig>  bulletConfigMap;

  _BulletConfigTable__isset __isset;

  void __set_bulletConfigMap(const std::map<int32_t, BulletConfig> & val);

  bool operator == (const BulletConfigTable & rhs) const
  {
    if (!(bulletConfigMap == rhs.bulletConfigMap))
      return false;
    return true;
  }
  bool operator != (const BulletConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BulletConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BulletConfigTable &a, BulletConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const BulletConfigTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SoundPath__isset {
  _SoundPath__isset() : type(false), path(false) {}
  bool type :1;
  bool path :1;
} _SoundPath__isset;

class SoundPath : public virtual ::apache::thrift::TBase {
 public:

  SoundPath(const SoundPath&);
  SoundPath& operator=(const SoundPath&);
  SoundPath() : type(), path() {
  }

  virtual ~SoundPath() throw();
  std::string type;
  std::string path;

  _SoundPath__isset __isset;

  void __set_type(const std::string& val);

  void __set_path(const std::string& val);

  bool operator == (const SoundPath & rhs) const
  {
    if (!(type == rhs.type))
      return false;
    if (!(path == rhs.path))
      return false;
    return true;
  }
  bool operator != (const SoundPath &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SoundPath & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SoundPath &a, SoundPath &b);

inline std::ostream& operator<<(std::ostream& out, const SoundPath& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SoundPathMap__isset {
  _SoundPathMap__isset() : soundPathMap(false) {}
  bool soundPathMap :1;
} _SoundPathMap__isset;

class SoundPathMap : public virtual ::apache::thrift::TBase {
 public:

  SoundPathMap(const SoundPathMap&);
  SoundPathMap& operator=(const SoundPathMap&);
  SoundPathMap() {
  }

  virtual ~SoundPathMap() throw();
  std::map<std::string, SoundPath>  soundPathMap;

  _SoundPathMap__isset __isset;

  void __set_soundPathMap(const std::map<std::string, SoundPath> & val);

  bool operator == (const SoundPathMap & rhs) const
  {
    if (!(soundPathMap == rhs.soundPathMap))
      return false;
    return true;
  }
  bool operator != (const SoundPathMap &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SoundPathMap & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SoundPathMap &a, SoundPathMap &b);

inline std::ostream& operator<<(std::ostream& out, const SoundPathMap& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ItemGeneratorConfig__isset {
  _ItemGeneratorConfig__isset() : id(false), itemIds(false), itemProbs(false), generateType(false) {}
  bool id :1;
  bool itemIds :1;
  bool itemProbs :1;
  bool generateType :1;
} _ItemGeneratorConfig__isset;

class ItemGeneratorConfig : public virtual ::apache::thrift::TBase {
 public:

  ItemGeneratorConfig(const ItemGeneratorConfig&);
  ItemGeneratorConfig& operator=(const ItemGeneratorConfig&);
  ItemGeneratorConfig() : id(0), generateType(0) {
  }

  virtual ~ItemGeneratorConfig() throw();
  int32_t id;
  std::vector<int32_t>  itemIds;
  std::vector<int32_t>  itemProbs;
  int32_t generateType;

  _ItemGeneratorConfig__isset __isset;

  void __set_id(const int32_t val);

  void __set_itemIds(const std::vector<int32_t> & val);

  void __set_itemProbs(const std::vector<int32_t> & val);

  void __set_generateType(const int32_t val);

  bool operator == (const ItemGeneratorConfig & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(itemIds == rhs.itemIds))
      return false;
    if (!(itemProbs == rhs.itemProbs))
      return false;
    if (!(generateType == rhs.generateType))
      return false;
    return true;
  }
  bool operator != (const ItemGeneratorConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemGeneratorConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemGeneratorConfig &a, ItemGeneratorConfig &b);

inline std::ostream& operator<<(std::ostream& out, const ItemGeneratorConfig& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ItemGeneratorConfigTable__isset {
  _ItemGeneratorConfigTable__isset() : itemGeneratorConfigMap(false) {}
  bool itemGeneratorConfigMap :1;
} _ItemGeneratorConfigTable__isset;

class ItemGeneratorConfigTable : public virtual ::apache::thrift::TBase {
 public:

  ItemGeneratorConfigTable(const ItemGeneratorConfigTable&);
  ItemGeneratorConfigTable& operator=(const ItemGeneratorConfigTable&);
  ItemGeneratorConfigTable() {
  }

  virtual ~ItemGeneratorConfigTable() throw();
  std::map<int32_t, ItemGeneratorConfig>  itemGeneratorConfigMap;

  _ItemGeneratorConfigTable__isset __isset;

  void __set_itemGeneratorConfigMap(const std::map<int32_t, ItemGeneratorConfig> & val);

  bool operator == (const ItemGeneratorConfigTable & rhs) const
  {
    if (!(itemGeneratorConfigMap == rhs.itemGeneratorConfigMap))
      return false;
    return true;
  }
  bool operator != (const ItemGeneratorConfigTable &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ItemGeneratorConfigTable & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ItemGeneratorConfigTable &a, ItemGeneratorConfigTable &b);

inline std::ostream& operator<<(std::ostream& out, const ItemGeneratorConfigTable& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _VersionConfig__isset {
  _VersionConfig__isset() : name(false) {}
  bool name :1;
} _VersionConfig__isset;

class VersionConfig : public virtual ::apache::thrift::TBase {
 public:

  VersionConfig(const VersionConfig&);
  VersionConfig& operator=(const VersionConfig&);
  VersionConfig() : name() {
  }

  virtual ~VersionConfig() throw();
  std::string name;

  _VersionConfig__isset __isset;

  void __set_name(const std::string& val);

  bool operator == (const VersionConfig & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const VersionConfig &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VersionConfig & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(VersionConfig &a, VersionConfig &b);

inline std::ostream& operator<<(std::ostream& out, const VersionConfig& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
