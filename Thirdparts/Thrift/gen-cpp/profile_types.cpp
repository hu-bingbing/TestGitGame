/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "profile_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CytxGame {

int _kUserLoginModeValues[] = {
  UserLoginMode::EUnLogin,
  UserLoginMode::EAccount,
  UserLoginMode::ETourist
};
const char* _kUserLoginModeNames[] = {
  "EUnLogin",
  "EAccount",
  "ETourist"
};
const std::map<int, const char*> _UserLoginMode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kUserLoginModeValues, _kUserLoginModeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kClassTypeValues[] = {
  ClassType::None,
  ClassType::Warrior,
  ClassType::Wizzard
};
const char* _kClassTypeNames[] = {
  "None",
  "Warrior",
  "Wizzard"
};
const std::map<int, const char*> _ClassType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kClassTypeValues, _kClassTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kGameStateValues[] = {
  GameState::Offline,
  GameState::Waiting,
  GameState::Playing
};
const char* _kGameStateNames[] = {
  "Offline",
  "Waiting",
  "Playing"
};
const std::map<int, const char*> _GameState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kGameStateValues, _kGameStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCommandTypeValues[] = {
  CommandType::Data,
  CommandType::Instantiate
};
const char* _kCommandTypeNames[] = {
  "Data",
  "Instantiate"
};
const std::map<int, const char*> _CommandType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCommandTypeValues, _kCommandTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCommandTargetTypeValues[] = {
  CommandTargetType::Server,
  CommandTargetType::Others,
  CommandTargetType::OthersBuffered,
  CommandTargetType::All,
  CommandTargetType::AllBuffered
};
const char* _kCommandTargetTypeNames[] = {
  "Server",
  "Others",
  "OthersBuffered",
  "All",
  "AllBuffered"
};
const std::map<int, const char*> _CommandTargetType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kCommandTargetTypeValues, _kCommandTargetTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kFrameCmdTypeValues[] = {
  FrameCmdType::Move,
  FrameCmdType::Jump
};
const char* _kFrameCmdTypeNames[] = {
  "Move",
  "Jump"
};
const std::map<int, const char*> _FrameCmdType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kFrameCmdTypeValues, _kFrameCmdTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSLoginResultValues[] = {
  CSLoginResult::ESuccess,
  CSLoginResult::EAccountNotExist,
  CSLoginResult::EAccountError,
  CSLoginResult::EPasswordError,
  CSLoginResult::EAccountAlreadyLogged,
  CSLoginResult::ELandingAccount
};
const char* _kCSLoginResultNames[] = {
  "ESuccess",
  "EAccountNotExist",
  "EAccountError",
  "EPasswordError",
  "EAccountAlreadyLogged",
  "ELandingAccount"
};
const std::map<int, const char*> _CSLoginResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kCSLoginResultValues, _kCSLoginResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSRegisterResultValues[] = {
  CSRegisterResult::ESuccess,
  CSRegisterResult::EAccountError,
  CSRegisterResult::EPasswordError,
  CSRegisterResult::EAccountAlreadyExist,
  CSRegisterResult::ELandingAccount
};
const char* _kCSRegisterResultNames[] = {
  "ESuccess",
  "EAccountError",
  "EPasswordError",
  "EAccountAlreadyExist",
  "ELandingAccount"
};
const std::map<int, const char*> _CSRegisterResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kCSRegisterResultValues, _kCSRegisterResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSTouristResultValues[] = {
  CSTouristResult::ESuccess,
  CSTouristResult::EAccountAlreadyLogged
};
const char* _kCSTouristResultNames[] = {
  "ESuccess",
  "EAccountAlreadyLogged"
};
const std::map<int, const char*> _CSTouristResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCSTouristResultValues, _kCSTouristResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSRandomNicknameResultValues[] = {
  CSRandomNicknameResult::ESuccess
};
const char* _kCSRandomNicknameResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _CSRandomNicknameResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kCSRandomNicknameResultValues, _kCSRandomNicknameResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSSetNicknameResultValues[] = {
  CSSetNicknameResult::ESuccess,
  CSSetNicknameResult::ENicknameLengthError,
  CSSetNicknameResult::ENicknameAlreadyExist,
  CSSetNicknameResult::EFaild
};
const char* _kCSSetNicknameResultNames[] = {
  "ESuccess",
  "ENicknameLengthError",
  "ENicknameAlreadyExist",
  "EFaild"
};
const std::map<int, const char*> _CSSetNicknameResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kCSSetNicknameResultValues, _kCSSetNicknameResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSSetClassTypeResultValues[] = {
  CSSetClassTypeResult::ESuccess,
  CSSetClassTypeResult::EAlreadySetClassType
};
const char* _kCSSetClassTypeResultNames[] = {
  "ESuccess",
  "EAlreadySetClassType"
};
const std::map<int, const char*> _CSSetClassTypeResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCSSetClassTypeResultValues, _kCSSetClassTypeResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSRefreshFriendListResultValues[] = {
  CSRefreshFriendListResult::ESuccess
};
const char* _kCSRefreshFriendListResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _CSRefreshFriendListResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kCSRefreshFriendListResultValues, _kCSRefreshFriendListResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSInvitationResultValues[] = {
  CSInvitationResult::ESuccess,
  CSInvitationResult::ETargetNotOnline,
  CSInvitationResult::ETargetNotWaiting,
  CSInvitationResult::ETargetClassTypeWizzard,
  CSInvitationResult::ETargetAlreadyInvited,
  CSInvitationResult::EAlreadyInvitation
};
const char* _kCSInvitationResultNames[] = {
  "ESuccess",
  "ETargetNotOnline",
  "ETargetNotWaiting",
  "ETargetClassTypeWizzard",
  "ETargetAlreadyInvited",
  "EAlreadyInvitation"
};
const std::map<int, const char*> _CSInvitationResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kCSInvitationResultValues, _kCSInvitationResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSConfirmInvitationResultValues[] = {
  CSConfirmInvitationResult::ESuccess
};
const char* _kCSConfirmInvitationResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _CSConfirmInvitationResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kCSConfirmInvitationResultValues, _kCSConfirmInvitationResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSCancelInvitationResultValues[] = {
  CSCancelInvitationResult::ESuccess
};
const char* _kCSCancelInvitationResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _CSCancelInvitationResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kCSCancelInvitationResultValues, _kCSCancelInvitationResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSExitInvitationResultValues[] = {
  CSExitInvitationResult::ESuccess
};
const char* _kCSExitInvitationResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _CSExitInvitationResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kCSExitInvitationResultValues, _kCSExitInvitationResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSChooseLevelResultValues[] = {
  CSChooseLevelResult::ESuccess
};
const char* _kCSChooseLevelResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _CSChooseLevelResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kCSChooseLevelResultValues, _kCSChooseLevelResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCSFindUserResultValues[] = {
  CSFindUserResult::ESuccess,
  CSFindUserResult::ETargetClassTypeWizzard
};
const char* _kCSFindUserResultNames[] = {
  "ESuccess",
  "ETargetClassTypeWizzard"
};
const std::map<int, const char*> _CSFindUserResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kCSFindUserResultValues, _kCSFindUserResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kCreateInstanceResultValues[] = {
  CreateInstanceResult::ESuccess
};
const char* _kCreateInstanceResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _CreateInstanceResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kCreateInstanceResultValues, _kCreateInstanceResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kInstanceListResultValues[] = {
  InstanceListResult::ESuccess
};
const char* _kInstanceListResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _InstanceListResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kInstanceListResultValues, _kInstanceListResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kJoinInstanceResultValues[] = {
  JoinInstanceResult::ESuccess,
  JoinInstanceResult::ENotFindInstance
};
const char* _kJoinInstanceResultNames[] = {
  "ESuccess",
  "ENotFindInstance"
};
const std::map<int, const char*> _JoinInstanceResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kJoinInstanceResultValues, _kJoinInstanceResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSaveDungeonProgressResultValues[] = {
  SaveDungeonProgressResult::ESuccess
};
const char* _kSaveDungeonProgressResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _SaveDungeonProgressResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kSaveDungeonProgressResultValues, _kSaveDungeonProgressResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kPauseResultValues[] = {
  PauseResult::ESuccess
};
const char* _kPauseResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _PauseResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kPauseResultValues, _kPauseResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kContinueResultValues[] = {
  ContinueResult::ESuccess
};
const char* _kContinueResultNames[] = {
  "ESuccess"
};
const std::map<int, const char*> _ContinueResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kContinueResultValues, _kContinueResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kQuickMatchResultValues[] = {
  QuickMatchResult::ESuccess,
  QuickMatchResult::ETargetNotOnline,
  QuickMatchResult::ETargetNotWaiting
};
const char* _kQuickMatchResultNames[] = {
  "ESuccess",
  "ETargetNotOnline",
  "ETargetNotWaiting"
};
const std::map<int, const char*> _QuickMatchResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kQuickMatchResultValues, _kQuickMatchResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStartGameResultValues[] = {
  StartGameResult::ESuccess,
  StartGameResult::ELastLevel
};
const char* _kStartGameResultNames[] = {
  "ESuccess",
  "ELastLevel"
};
const std::map<int, const char*> _StartGameResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kStartGameResultValues, _kStartGameResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStartGameConfirmResultValues[] = {
  StartGameConfirmResult::ESuccess,
  StartGameConfirmResult::EConfirmTimeout
};
const char* _kStartGameConfirmResultNames[] = {
  "ESuccess",
  "EConfirmTimeout"
};
const std::map<int, const char*> _StartGameConfirmResult_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kStartGameConfirmResultValues, _kStartGameConfirmResultNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Position::~Position() throw() {
}


void Position::__set_x(const double val) {
  this->x = val;
}

void Position::__set_y(const double val) {
  this->y = val;
}

void Position::__set_z(const double val) {
  this->z = val;
}

uint32_t Position::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Position::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Position");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 30);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Position &a, Position &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.__isset, b.__isset);
}

Position::Position(const Position& other0) {
  x = other0.x;
  y = other0.y;
  z = other0.z;
  __isset = other0.__isset;
}
Position& Position::operator=(const Position& other1) {
  x = other1.x;
  y = other1.y;
  z = other1.z;
  __isset = other1.__isset;
  return *this;
}
void Position::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Position(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ")";
}


Rotation::~Rotation() throw() {
}


void Rotation::__set_x(const double val) {
  this->x = val;
}

void Rotation::__set_y(const double val) {
  this->y = val;
}

void Rotation::__set_z(const double val) {
  this->z = val;
}

void Rotation::__set_w(const double val) {
  this->w = val;
}

uint32_t Rotation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->w);
          this->__isset.w = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Rotation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Rotation");

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 30);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("w", ::apache::thrift::protocol::T_DOUBLE, 40);
  xfer += oprot->writeDouble(this->w);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Rotation &a, Rotation &b) {
  using ::std::swap;
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.w, b.w);
  swap(a.__isset, b.__isset);
}

Rotation::Rotation(const Rotation& other2) {
  x = other2.x;
  y = other2.y;
  z = other2.z;
  w = other2.w;
  __isset = other2.__isset;
}
Rotation& Rotation::operator=(const Rotation& other3) {
  x = other3.x;
  y = other3.y;
  z = other3.z;
  w = other3.w;
  __isset = other3.__isset;
  return *this;
}
void Rotation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Rotation(";
  out << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ", " << "w=" << to_string(w);
  out << ")";
}


PlayerData::~PlayerData() throw() {
}


void PlayerData::__set_userId(const int32_t val) {
  this->userId = val;
}

void PlayerData::__set_nickname(const std::string& val) {
  this->nickname = val;
}

void PlayerData::__set_classType(const ClassType::type val) {
  this->classType = val;
}

void PlayerData::__set_gameState(const GameState::type val) {
  this->gameState = val;
}

void PlayerData::__set_levelDataBest(const int32_t val) {
  this->levelDataBest = val;
}

uint32_t PlayerData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast4;
          xfer += iprot->readI32(ecast4);
          this->classType = (ClassType::type)ecast4;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->gameState = (GameState::type)ecast5;
          this->__isset.gameState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelDataBest);
          this->__isset.levelDataBest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlayerData");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gameState", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32((int32_t)this->gameState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelDataBest", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->levelDataBest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerData &a, PlayerData &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.nickname, b.nickname);
  swap(a.classType, b.classType);
  swap(a.gameState, b.gameState);
  swap(a.levelDataBest, b.levelDataBest);
  swap(a.__isset, b.__isset);
}

PlayerData::PlayerData(const PlayerData& other6) {
  userId = other6.userId;
  nickname = other6.nickname;
  classType = other6.classType;
  gameState = other6.gameState;
  levelDataBest = other6.levelDataBest;
  __isset = other6.__isset;
}
PlayerData& PlayerData::operator=(const PlayerData& other7) {
  userId = other7.userId;
  nickname = other7.nickname;
  classType = other7.classType;
  gameState = other7.gameState;
  levelDataBest = other7.levelDataBest;
  __isset = other7.__isset;
  return *this;
}
void PlayerData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlayerData(";
  out << "userId=" << to_string(userId);
  out << ", " << "nickname=" << to_string(nickname);
  out << ", " << "classType=" << to_string(classType);
  out << ", " << "gameState=" << to_string(gameState);
  out << ", " << "levelDataBest=" << to_string(levelDataBest);
  out << ")";
}


ServerData::~ServerData() throw() {
}


void ServerData::__set_connId(const int32_t val) {
  this->connId = val;
}

uint32_t ServerData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->connId);
          this->__isset.connId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ServerData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ServerData");

  xfer += oprot->writeFieldBegin("connId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->connId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ServerData &a, ServerData &b) {
  using ::std::swap;
  swap(a.connId, b.connId);
  swap(a.__isset, b.__isset);
}

ServerData::ServerData(const ServerData& other8) {
  connId = other8.connId;
  __isset = other8.__isset;
}
ServerData& ServerData::operator=(const ServerData& other9) {
  connId = other9.connId;
  __isset = other9.__isset;
  return *this;
}
void ServerData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ServerData(";
  out << "connId=" << to_string(connId);
  out << ")";
}


PetData::~PetData() throw() {
}


void PetData::__set_petId(const int32_t val) {
  this->petId = val;
}

void PetData::__set_health(const int32_t val) {
  this->health = val;
}

uint32_t PetData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->petId);
          this->__isset.petId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->health);
          this->__isset.health = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PetData");

  xfer += oprot->writeFieldBegin("petId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->petId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("health", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->health);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetData &a, PetData &b) {
  using ::std::swap;
  swap(a.petId, b.petId);
  swap(a.health, b.health);
  swap(a.__isset, b.__isset);
}

PetData::PetData(const PetData& other10) {
  petId = other10.petId;
  health = other10.health;
  __isset = other10.__isset;
}
PetData& PetData::operator=(const PetData& other11) {
  petId = other11.petId;
  health = other11.health;
  __isset = other11.__isset;
  return *this;
}
void PetData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PetData(";
  out << "petId=" << to_string(petId);
  out << ", " << "health=" << to_string(health);
  out << ")";
}


LevelData::~LevelData() throw() {
}


void LevelData::__set_levelProgress(const int32_t val) {
  this->levelProgress = val;
}

void LevelData::__set_petDataList(const std::vector<PetData> & val) {
  this->petDataList = val;
}

void LevelData::__set_restMana(const int32_t val) {
  this->restMana = val;
}

uint32_t LevelData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelProgress);
          this->__isset.levelProgress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->petDataList.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->petDataList.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += this->petDataList[_i16].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.petDataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->restMana);
          this->__isset.restMana = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t LevelData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LevelData");

  xfer += oprot->writeFieldBegin("levelProgress", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->levelProgress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("petDataList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->petDataList.size()));
    std::vector<PetData> ::const_iterator _iter17;
    for (_iter17 = this->petDataList.begin(); _iter17 != this->petDataList.end(); ++_iter17)
    {
      xfer += (*_iter17).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("restMana", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->restMana);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LevelData &a, LevelData &b) {
  using ::std::swap;
  swap(a.levelProgress, b.levelProgress);
  swap(a.petDataList, b.petDataList);
  swap(a.restMana, b.restMana);
  swap(a.__isset, b.__isset);
}

LevelData::LevelData(const LevelData& other18) {
  levelProgress = other18.levelProgress;
  petDataList = other18.petDataList;
  restMana = other18.restMana;
  __isset = other18.__isset;
}
LevelData& LevelData::operator=(const LevelData& other19) {
  levelProgress = other19.levelProgress;
  petDataList = other19.petDataList;
  restMana = other19.restMana;
  __isset = other19.__isset;
  return *this;
}
void LevelData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LevelData(";
  out << "levelProgress=" << to_string(levelProgress);
  out << ", " << "petDataList=" << to_string(petDataList);
  out << ", " << "restMana=" << to_string(restMana);
  out << ")";
}


RoleData::~RoleData() throw() {
}


void RoleData::__set_nickname(const std::string& val) {
  this->nickname = val;
}

void RoleData::__set_classType(const ClassType::type val) {
  this->classType = val;
}

void RoleData::__set_gameState(const GameState::type val) {
  this->gameState = val;
}

void RoleData::__set_levelDataBest(const int32_t val) {
  this->levelDataBest = val;
}

void RoleData::__set_levelDataMap(const std::map<int32_t, LevelData> & val) {
  this->levelDataMap = val;
}

void RoleData::__set_playerMap(const std::map<int32_t, PlayerData> & val) {
  this->playerMap = val;
}

uint32_t RoleData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast20;
          xfer += iprot->readI32(ecast20);
          this->classType = (ClassType::type)ecast20;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast21;
          xfer += iprot->readI32(ecast21);
          this->gameState = (GameState::type)ecast21;
          this->__isset.gameState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelDataBest);
          this->__isset.levelDataBest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 130:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->levelDataMap.clear();
            uint32_t _size22;
            ::apache::thrift::protocol::TType _ktype23;
            ::apache::thrift::protocol::TType _vtype24;
            xfer += iprot->readMapBegin(_ktype23, _vtype24, _size22);
            uint32_t _i26;
            for (_i26 = 0; _i26 < _size22; ++_i26)
            {
              int32_t _key27;
              xfer += iprot->readI32(_key27);
              LevelData& _val28 = this->levelDataMap[_key27];
              xfer += _val28.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.levelDataMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 210:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->playerMap.clear();
            uint32_t _size29;
            ::apache::thrift::protocol::TType _ktype30;
            ::apache::thrift::protocol::TType _vtype31;
            xfer += iprot->readMapBegin(_ktype30, _vtype31, _size29);
            uint32_t _i33;
            for (_i33 = 0; _i33 < _size29; ++_i33)
            {
              int32_t _key34;
              xfer += iprot->readI32(_key34);
              PlayerData& _val35 = this->playerMap[_key34];
              xfer += _val35.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.playerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RoleData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RoleData");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gameState", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32((int32_t)this->gameState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelDataBest", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->levelDataBest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelDataMap", ::apache::thrift::protocol::T_MAP, 130);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->levelDataMap.size()));
    std::map<int32_t, LevelData> ::const_iterator _iter36;
    for (_iter36 = this->levelDataMap.begin(); _iter36 != this->levelDataMap.end(); ++_iter36)
    {
      xfer += oprot->writeI32(_iter36->first);
      xfer += _iter36->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerMap", ::apache::thrift::protocol::T_MAP, 210);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerMap.size()));
    std::map<int32_t, PlayerData> ::const_iterator _iter37;
    for (_iter37 = this->playerMap.begin(); _iter37 != this->playerMap.end(); ++_iter37)
    {
      xfer += oprot->writeI32(_iter37->first);
      xfer += _iter37->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RoleData &a, RoleData &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.classType, b.classType);
  swap(a.gameState, b.gameState);
  swap(a.levelDataBest, b.levelDataBest);
  swap(a.levelDataMap, b.levelDataMap);
  swap(a.playerMap, b.playerMap);
  swap(a.__isset, b.__isset);
}

RoleData::RoleData(const RoleData& other38) {
  nickname = other38.nickname;
  classType = other38.classType;
  gameState = other38.gameState;
  levelDataBest = other38.levelDataBest;
  levelDataMap = other38.levelDataMap;
  playerMap = other38.playerMap;
  __isset = other38.__isset;
}
RoleData& RoleData::operator=(const RoleData& other39) {
  nickname = other39.nickname;
  classType = other39.classType;
  gameState = other39.gameState;
  levelDataBest = other39.levelDataBest;
  levelDataMap = other39.levelDataMap;
  playerMap = other39.playerMap;
  __isset = other39.__isset;
  return *this;
}
void RoleData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RoleData(";
  out << "nickname=" << to_string(nickname);
  out << ", " << "classType=" << to_string(classType);
  out << ", " << "gameState=" << to_string(gameState);
  out << ", " << "levelDataBest=" << to_string(levelDataBest);
  out << ", " << "levelDataMap=" << to_string(levelDataMap);
  out << ", " << "playerMap=" << to_string(playerMap);
  out << ")";
}


UserData::~UserData() throw() {
}


void UserData::__set_userId(const int32_t val) {
  this->userId = val;
}

void UserData::__set_userAccount(const std::string& val) {
  this->userAccount = val;
}

void UserData::__set_userPassword(const std::string& val) {
  this->userPassword = val;
}

void UserData::__set_userLoginMode(const int32_t val) {
  this->userLoginMode = val;
}

void UserData::__set_alreadyRegist(const bool val) {
  this->alreadyRegist = val;
}

void UserData::__set_roleData(const RoleData& val) {
  this->roleData = val;
}

void UserData::__set_serverData(const ServerData& val) {
  this->serverData = val;
}

uint32_t UserData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userAccount);
          this->__isset.userAccount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userPassword);
          this->__isset.userPassword = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userLoginMode);
          this->__isset.userLoginMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->alreadyRegist);
          this->__isset.alreadyRegist = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->roleData.read(iprot);
          this->__isset.roleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->serverData.read(iprot);
          this->__isset.serverData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UserData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UserData");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userAccount", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->userAccount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userPassword", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->userPassword);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userLoginMode", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->userLoginMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("alreadyRegist", ::apache::thrift::protocol::T_BOOL, 50);
  xfer += oprot->writeBool(this->alreadyRegist);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roleData", ::apache::thrift::protocol::T_STRUCT, 60);
  xfer += this->roleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverData", ::apache::thrift::protocol::T_STRUCT, 70);
  xfer += this->serverData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UserData &a, UserData &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.userAccount, b.userAccount);
  swap(a.userPassword, b.userPassword);
  swap(a.userLoginMode, b.userLoginMode);
  swap(a.alreadyRegist, b.alreadyRegist);
  swap(a.roleData, b.roleData);
  swap(a.serverData, b.serverData);
  swap(a.__isset, b.__isset);
}

UserData::UserData(const UserData& other40) {
  userId = other40.userId;
  userAccount = other40.userAccount;
  userPassword = other40.userPassword;
  userLoginMode = other40.userLoginMode;
  alreadyRegist = other40.alreadyRegist;
  roleData = other40.roleData;
  serverData = other40.serverData;
  __isset = other40.__isset;
}
UserData& UserData::operator=(const UserData& other41) {
  userId = other41.userId;
  userAccount = other41.userAccount;
  userPassword = other41.userPassword;
  userLoginMode = other41.userLoginMode;
  alreadyRegist = other41.alreadyRegist;
  roleData = other41.roleData;
  serverData = other41.serverData;
  __isset = other41.__isset;
  return *this;
}
void UserData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UserData(";
  out << "userId=" << to_string(userId);
  out << ", " << "userAccount=" << to_string(userAccount);
  out << ", " << "userPassword=" << to_string(userPassword);
  out << ", " << "userLoginMode=" << to_string(userLoginMode);
  out << ", " << "alreadyRegist=" << to_string(alreadyRegist);
  out << ", " << "roleData=" << to_string(roleData);
  out << ", " << "serverData=" << to_string(serverData);
  out << ")";
}


InstanceData::~InstanceData() throw() {
}


void InstanceData::__set_instanceId(const int32_t val) {
  this->instanceId = val;
}

void InstanceData::__set_masterUserId(const int32_t val) {
  this->masterUserId = val;
}

void InstanceData::__set_instanceName(const std::string& val) {
  this->instanceName = val;
}

void InstanceData::__set_playerMap(const std::map<int32_t, PlayerData> & val) {
  this->playerMap = val;
}

void InstanceData::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void InstanceData::__set_levelData(const LevelData& val) {
  this->levelData = val;
}

uint32_t InstanceData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->instanceId);
          this->__isset.instanceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->masterUserId);
          this->__isset.masterUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instanceName);
          this->__isset.instanceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->playerMap.clear();
            uint32_t _size42;
            ::apache::thrift::protocol::TType _ktype43;
            ::apache::thrift::protocol::TType _vtype44;
            xfer += iprot->readMapBegin(_ktype43, _vtype44, _size42);
            uint32_t _i46;
            for (_i46 = 0; _i46 < _size42; ++_i46)
            {
              int32_t _key47;
              xfer += iprot->readI32(_key47);
              PlayerData& _val48 = this->playerMap[_key47];
              xfer += _val48.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.playerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InstanceData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InstanceData");

  xfer += oprot->writeFieldBegin("instanceId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->instanceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("masterUserId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->masterUserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instanceName", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->instanceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerMap", ::apache::thrift::protocol::T_MAP, 40);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerMap.size()));
    std::map<int32_t, PlayerData> ::const_iterator _iter49;
    for (_iter49 = this->playerMap.begin(); _iter49 != this->playerMap.end(); ++_iter49)
    {
      xfer += oprot->writeI32(_iter49->first);
      xfer += _iter49->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 60);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InstanceData &a, InstanceData &b) {
  using ::std::swap;
  swap(a.instanceId, b.instanceId);
  swap(a.masterUserId, b.masterUserId);
  swap(a.instanceName, b.instanceName);
  swap(a.playerMap, b.playerMap);
  swap(a.levelId, b.levelId);
  swap(a.levelData, b.levelData);
  swap(a.__isset, b.__isset);
}

InstanceData::InstanceData(const InstanceData& other50) {
  instanceId = other50.instanceId;
  masterUserId = other50.masterUserId;
  instanceName = other50.instanceName;
  playerMap = other50.playerMap;
  levelId = other50.levelId;
  levelData = other50.levelData;
  __isset = other50.__isset;
}
InstanceData& InstanceData::operator=(const InstanceData& other51) {
  instanceId = other51.instanceId;
  masterUserId = other51.masterUserId;
  instanceName = other51.instanceName;
  playerMap = other51.playerMap;
  levelId = other51.levelId;
  levelData = other51.levelData;
  __isset = other51.__isset;
  return *this;
}
void InstanceData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InstanceData(";
  out << "instanceId=" << to_string(instanceId);
  out << ", " << "masterUserId=" << to_string(masterUserId);
  out << ", " << "instanceName=" << to_string(instanceName);
  out << ", " << "playerMap=" << to_string(playerMap);
  out << ", " << "levelId=" << to_string(levelId);
  out << ", " << "levelData=" << to_string(levelData);
  out << ")";
}


UnitSyncData::~UnitSyncData() throw() {
}


void UnitSyncData::__set_uid(const int32_t val) {
  this->uid = val;
}

void UnitSyncData::__set_pos(const Position& val) {
  this->pos = val;
}

void UnitSyncData::__set_rot(const Rotation& val) {
  this->rot = val;
}

void UnitSyncData::__set_dir(const Position& val) {
  this->dir = val;
}

uint32_t UnitSyncData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->uid);
          this->__isset.uid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pos.read(iprot);
          this->__isset.pos = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rot.read(iprot);
          this->__isset.rot = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dir.read(iprot);
          this->__isset.dir = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnitSyncData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnitSyncData");

  xfer += oprot->writeFieldBegin("uid", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->uid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pos", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->pos.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rot", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->rot.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dir", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->dir.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnitSyncData &a, UnitSyncData &b) {
  using ::std::swap;
  swap(a.uid, b.uid);
  swap(a.pos, b.pos);
  swap(a.rot, b.rot);
  swap(a.dir, b.dir);
  swap(a.__isset, b.__isset);
}

UnitSyncData::UnitSyncData(const UnitSyncData& other52) {
  uid = other52.uid;
  pos = other52.pos;
  rot = other52.rot;
  dir = other52.dir;
  __isset = other52.__isset;
}
UnitSyncData& UnitSyncData::operator=(const UnitSyncData& other53) {
  uid = other53.uid;
  pos = other53.pos;
  rot = other53.rot;
  dir = other53.dir;
  __isset = other53.__isset;
  return *this;
}
void UnitSyncData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnitSyncData(";
  out << "uid=" << to_string(uid);
  out << ", " << "pos=" << to_string(pos);
  out << ", " << "rot=" << to_string(rot);
  out << ", " << "dir=" << to_string(dir);
  out << ")";
}


UnitSyncDataList::~UnitSyncDataList() throw() {
}


void UnitSyncDataList::__set_dataList(const std::vector<UnitSyncData> & val) {
  this->dataList = val;
}

uint32_t UnitSyncDataList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataList.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->dataList.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->dataList[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t UnitSyncDataList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("UnitSyncDataList");

  xfer += oprot->writeFieldBegin("dataList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dataList.size()));
    std::vector<UnitSyncData> ::const_iterator _iter59;
    for (_iter59 = this->dataList.begin(); _iter59 != this->dataList.end(); ++_iter59)
    {
      xfer += (*_iter59).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(UnitSyncDataList &a, UnitSyncDataList &b) {
  using ::std::swap;
  swap(a.dataList, b.dataList);
  swap(a.__isset, b.__isset);
}

UnitSyncDataList::UnitSyncDataList(const UnitSyncDataList& other60) {
  dataList = other60.dataList;
  __isset = other60.__isset;
}
UnitSyncDataList& UnitSyncDataList::operator=(const UnitSyncDataList& other61) {
  dataList = other61.dataList;
  __isset = other61.__isset;
  return *this;
}
void UnitSyncDataList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "UnitSyncDataList(";
  out << "dataList=" << to_string(dataList);
  out << ")";
}


CommandData::~CommandData() throw() {
}


void CommandData::__set_commandType(const CommandType::type val) {
  this->commandType = val;
}

void CommandData::__set_dataLength(const int16_t val) {
  this->dataLength = val;
}

void CommandData::__set_data(const std::string& val) {
  this->data = val;
}

void CommandData::__set_target(const CommandTargetType::type val) {
  this->target = val;
}

uint32_t CommandData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast62;
          xfer += iprot->readI32(ecast62);
          this->commandType = (CommandType::type)ecast62;
          this->__isset.commandType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->dataLength);
          this->__isset.dataLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast63;
          xfer += iprot->readI32(ecast63);
          this->target = (CommandTargetType::type)ecast63;
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CommandData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CommandData");

  xfer += oprot->writeFieldBegin("commandType", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->commandType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataLength", ::apache::thrift::protocol::T_I16, 20);
  xfer += oprot->writeI16(this->dataLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32((int32_t)this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CommandData &a, CommandData &b) {
  using ::std::swap;
  swap(a.commandType, b.commandType);
  swap(a.dataLength, b.dataLength);
  swap(a.data, b.data);
  swap(a.target, b.target);
  swap(a.__isset, b.__isset);
}

CommandData::CommandData(const CommandData& other64) {
  commandType = other64.commandType;
  dataLength = other64.dataLength;
  data = other64.data;
  target = other64.target;
  __isset = other64.__isset;
}
CommandData& CommandData::operator=(const CommandData& other65) {
  commandType = other65.commandType;
  dataLength = other65.dataLength;
  data = other65.data;
  target = other65.target;
  __isset = other65.__isset;
  return *this;
}
void CommandData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CommandData(";
  out << "commandType=" << to_string(commandType);
  out << ", " << "dataLength=" << to_string(dataLength);
  out << ", " << "data=" << to_string(data);
  out << ", " << "target=" << to_string(target);
  out << ")";
}


FrameCommand::~FrameCommand() throw() {
}


void FrameCommand::__set_frameCmdType(const FrameCmdType::type val) {
  this->frameCmdType = val;
}

void FrameCommand::__set_playerId(const int32_t val) {
  this->playerId = val;
}

void FrameCommand::__set_dataLength(const int16_t val) {
  this->dataLength = val;
}

void FrameCommand::__set_data(const std::string& val) {
  this->data = val;
}

uint32_t FrameCommand::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast66;
          xfer += iprot->readI32(ecast66);
          this->frameCmdType = (FrameCmdType::type)ecast66;
          this->__isset.frameCmdType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playerId);
          this->__isset.playerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->dataLength);
          this->__isset.dataLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readBinary(this->data);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FrameCommand::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FrameCommand");

  xfer += oprot->writeFieldBegin("frameCmdType", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->frameCmdType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->playerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataLength", ::apache::thrift::protocol::T_I16, 30);
  xfer += oprot->writeI16(this->dataLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeBinary(this->data);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FrameCommand &a, FrameCommand &b) {
  using ::std::swap;
  swap(a.frameCmdType, b.frameCmdType);
  swap(a.playerId, b.playerId);
  swap(a.dataLength, b.dataLength);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

FrameCommand::FrameCommand(const FrameCommand& other67) {
  frameCmdType = other67.frameCmdType;
  playerId = other67.playerId;
  dataLength = other67.dataLength;
  data = other67.data;
  __isset = other67.__isset;
}
FrameCommand& FrameCommand::operator=(const FrameCommand& other68) {
  frameCmdType = other68.frameCmdType;
  playerId = other68.playerId;
  dataLength = other68.dataLength;
  data = other68.data;
  __isset = other68.__isset;
  return *this;
}
void FrameCommand::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FrameCommand(";
  out << "frameCmdType=" << to_string(frameCmdType);
  out << ", " << "playerId=" << to_string(playerId);
  out << ", " << "dataLength=" << to_string(dataLength);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


FrameData::~FrameData() throw() {
}


void FrameData::__set_frameIndex(const int32_t val) {
  this->frameIndex = val;
}

void FrameData::__set_commandList(const std::vector<FrameCommand> & val) {
  this->commandList = val;
}

uint32_t FrameData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->frameIndex);
          this->__isset.frameIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->commandList.clear();
            uint32_t _size69;
            ::apache::thrift::protocol::TType _etype72;
            xfer += iprot->readListBegin(_etype72, _size69);
            this->commandList.resize(_size69);
            uint32_t _i73;
            for (_i73 = 0; _i73 < _size69; ++_i73)
            {
              xfer += this->commandList[_i73].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.commandList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FrameData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FrameData");

  xfer += oprot->writeFieldBegin("frameIndex", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->frameIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("commandList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->commandList.size()));
    std::vector<FrameCommand> ::const_iterator _iter74;
    for (_iter74 = this->commandList.begin(); _iter74 != this->commandList.end(); ++_iter74)
    {
      xfer += (*_iter74).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FrameData &a, FrameData &b) {
  using ::std::swap;
  swap(a.frameIndex, b.frameIndex);
  swap(a.commandList, b.commandList);
  swap(a.__isset, b.__isset);
}

FrameData::FrameData(const FrameData& other75) {
  frameIndex = other75.frameIndex;
  commandList = other75.commandList;
  __isset = other75.__isset;
}
FrameData& FrameData::operator=(const FrameData& other76) {
  frameIndex = other76.frameIndex;
  commandList = other76.commandList;
  __isset = other76.__isset;
  return *this;
}
void FrameData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FrameData(";
  out << "frameIndex=" << to_string(frameIndex);
  out << ", " << "commandList=" << to_string(commandList);
  out << ")";
}


ReplayData::~ReplayData() throw() {
}


void ReplayData::__set_timeData(const int64_t val) {
  this->timeData = val;
}

void ReplayData::__set_classType(const ClassType::type val) {
  this->classType = val;
}

void ReplayData::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void ReplayData::__set_levelProgress(const int32_t val) {
  this->levelProgress = val;
}

uint32_t ReplayData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeData);
          this->__isset.timeData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast77;
          xfer += iprot->readI32(ecast77);
          this->classType = (ClassType::type)ecast77;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelProgress);
          this->__isset.levelProgress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ReplayData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ReplayData");

  xfer += oprot->writeFieldBegin("timeData", ::apache::thrift::protocol::T_I64, 20);
  xfer += oprot->writeI64(this->timeData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelProgress", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->levelProgress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ReplayData &a, ReplayData &b) {
  using ::std::swap;
  swap(a.timeData, b.timeData);
  swap(a.classType, b.classType);
  swap(a.levelId, b.levelId);
  swap(a.levelProgress, b.levelProgress);
  swap(a.__isset, b.__isset);
}

ReplayData::ReplayData(const ReplayData& other78) {
  timeData = other78.timeData;
  classType = other78.classType;
  levelId = other78.levelId;
  levelProgress = other78.levelProgress;
  __isset = other78.__isset;
}
ReplayData& ReplayData::operator=(const ReplayData& other79) {
  timeData = other79.timeData;
  classType = other79.classType;
  levelId = other79.levelId;
  levelProgress = other79.levelProgress;
  __isset = other79.__isset;
  return *this;
}
void ReplayData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ReplayData(";
  out << "timeData=" << to_string(timeData);
  out << ", " << "classType=" << to_string(classType);
  out << ", " << "levelId=" << to_string(levelId);
  out << ", " << "levelProgress=" << to_string(levelProgress);
  out << ")";
}


AccountData::~AccountData() throw() {
}


void AccountData::__set_id(const int32_t val) {
  this->id = val;
}

void AccountData::__set_sessionKey(const std::string& val) {
  this->sessionKey = val;
}

void AccountData::__set_channel(const std::string& val) {
  this->channel = val;
}

void AccountData::__set_openId(const std::string& val) {
  this->openId = val;
}

void AccountData::__set_lastLoginTime(const int64_t val) {
  this->lastLoginTime = val;
}

uint32_t AccountData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionKey);
          this->__isset.sessionKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->channel);
          this->__isset.channel = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->openId);
          this->__isset.openId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->lastLoginTime);
          this->__isset.lastLoginTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AccountData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AccountData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionKey", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->sessionKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("channel", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->channel);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("openId", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->openId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("lastLoginTime", ::apache::thrift::protocol::T_I64, 50);
  xfer += oprot->writeI64(this->lastLoginTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AccountData &a, AccountData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.sessionKey, b.sessionKey);
  swap(a.channel, b.channel);
  swap(a.openId, b.openId);
  swap(a.lastLoginTime, b.lastLoginTime);
  swap(a.__isset, b.__isset);
}

AccountData::AccountData(const AccountData& other80) {
  id = other80.id;
  sessionKey = other80.sessionKey;
  channel = other80.channel;
  openId = other80.openId;
  lastLoginTime = other80.lastLoginTime;
  __isset = other80.__isset;
}
AccountData& AccountData::operator=(const AccountData& other81) {
  id = other81.id;
  sessionKey = other81.sessionKey;
  channel = other81.channel;
  openId = other81.openId;
  lastLoginTime = other81.lastLoginTime;
  __isset = other81.__isset;
  return *this;
}
void AccountData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AccountData(";
  out << "id=" << to_string(id);
  out << ", " << "sessionKey=" << to_string(sessionKey);
  out << ", " << "channel=" << to_string(channel);
  out << ", " << "openId=" << to_string(openId);
  out << ", " << "lastLoginTime=" << to_string(lastLoginTime);
  out << ")";
}

} // namespace
