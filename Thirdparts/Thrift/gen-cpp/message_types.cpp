/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "message_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CytxGame {

int _kMessageIdValues[] = {
  MessageId::CS_Login,
  MessageId::SC_Login,
  MessageId::CS_Register,
  MessageId::SC_Register,
  MessageId::CS_TouristLogin,
  MessageId::SC_TouristLogin,
  MessageId::CS_Logout,
  MessageId::SC_Logout,
  MessageId::C_LoginGame,
  MessageId::S_LoginGame,
  MessageId::SC_Connect,
  MessageId::CS_ConnectKey,
  MessageId::SC_ConnectKey,
  MessageId::CS_TouristLoginGame,
  MessageId::SC_TouristLoginGame,
  MessageId::CS_CreateInstance,
  MessageId::SC_CreateInstance,
  MessageId::CS_InstanceList,
  MessageId::SC_InstanceList,
  MessageId::CS_JoinInstance,
  MessageId::SC_JoinInstance,
  MessageId::CS_ExitInstance,
  MessageId::SC_ExitInstance,
  MessageId::CS_StartGame,
  MessageId::SC_StartGame,
  MessageId::CS_StartGameConfirm,
  MessageId::SC_StartGameConfirm,
  MessageId::CS_EndGame,
  MessageId::SC_EndGame,
  MessageId::CS_ExitGame,
  MessageId::SC_ExitGame,
  MessageId::CS_RetrieveCommand,
  MessageId::SC_RetrieveCommand,
  MessageId::CS_Frame,
  MessageId::SC_Frame,
  MessageId::CS_RandomNickname,
  MessageId::SC_RandomNickname,
  MessageId::CS_SetNickname,
  MessageId::SC_SetNickname,
  MessageId::CS_SetClassType,
  MessageId::SC_SetClassType,
  MessageId::CS_RefreshFriendList,
  MessageId::SC_RefreshFriendList,
  MessageId::CS_Invitation,
  MessageId::SC_Invitation,
  MessageId::SC_NoticeInvitation,
  MessageId::CS_ConfirmInvitation,
  MessageId::SC_ConfirmInvitation,
  MessageId::SC_NoticeConfirmInvitation,
  MessageId::CS_CancelInvitation,
  MessageId::SC_CancelInvitation,
  MessageId::SC_NoticeCancelInvitation,
  MessageId::CS_ExitInvitation,
  MessageId::SC_ExitInvitation,
  MessageId::CS_ChooseLevel,
  MessageId::SC_ChooseLevel,
  MessageId::CS_FindUser,
  MessageId::SC_FindUser,
  MessageId::CS_SaveDungeonProgress,
  MessageId::SC_SaveDungeonProgress,
  MessageId::CS_Pause,
  MessageId::SC_Pause,
  MessageId::CS_Continue,
  MessageId::SC_Continue,
  MessageId::CS_RestartGame,
  MessageId::SC_RestartGame,
  MessageId::CS_QuickMatch,
  MessageId::SC_QuickMatch,
  MessageId::CS_QuickMatchLan,
  MessageId::SC_QuickMatchLan,
  MessageId::CS_QuickMatchCancel,
  MessageId::SC_QuickMatchCancel,
  MessageId::CS_ReplayList,
  MessageId::SC_ReplayList,
  MessageId::CS_ReplayChoose,
  MessageId::SC_ReplayChoose,
  MessageId::CS_ReplayStart,
  MessageId::SC_ReplayStart,
  MessageId::CS_ReplayEnd,
  MessageId::SC_ReplayEnd,
  MessageId::CS_QuickMatchClassType,
  MessageId::SC_QuickMatchClassType,
  MessageId::CS_TestProtocol,
  MessageId::SC_TestProtocol,
  MessageId::CS_Ping,
  MessageId::SC_Ping
};
const char* _kMessageIdNames[] = {
  "CS_Login",
  "SC_Login",
  "CS_Register",
  "SC_Register",
  "CS_TouristLogin",
  "SC_TouristLogin",
  "CS_Logout",
  "SC_Logout",
  "C_LoginGame",
  "S_LoginGame",
  "SC_Connect",
  "CS_ConnectKey",
  "SC_ConnectKey",
  "CS_TouristLoginGame",
  "SC_TouristLoginGame",
  "CS_CreateInstance",
  "SC_CreateInstance",
  "CS_InstanceList",
  "SC_InstanceList",
  "CS_JoinInstance",
  "SC_JoinInstance",
  "CS_ExitInstance",
  "SC_ExitInstance",
  "CS_StartGame",
  "SC_StartGame",
  "CS_StartGameConfirm",
  "SC_StartGameConfirm",
  "CS_EndGame",
  "SC_EndGame",
  "CS_ExitGame",
  "SC_ExitGame",
  "CS_RetrieveCommand",
  "SC_RetrieveCommand",
  "CS_Frame",
  "SC_Frame",
  "CS_RandomNickname",
  "SC_RandomNickname",
  "CS_SetNickname",
  "SC_SetNickname",
  "CS_SetClassType",
  "SC_SetClassType",
  "CS_RefreshFriendList",
  "SC_RefreshFriendList",
  "CS_Invitation",
  "SC_Invitation",
  "SC_NoticeInvitation",
  "CS_ConfirmInvitation",
  "SC_ConfirmInvitation",
  "SC_NoticeConfirmInvitation",
  "CS_CancelInvitation",
  "SC_CancelInvitation",
  "SC_NoticeCancelInvitation",
  "CS_ExitInvitation",
  "SC_ExitInvitation",
  "CS_ChooseLevel",
  "SC_ChooseLevel",
  "CS_FindUser",
  "SC_FindUser",
  "CS_SaveDungeonProgress",
  "SC_SaveDungeonProgress",
  "CS_Pause",
  "SC_Pause",
  "CS_Continue",
  "SC_Continue",
  "CS_RestartGame",
  "SC_RestartGame",
  "CS_QuickMatch",
  "SC_QuickMatch",
  "CS_QuickMatchLan",
  "SC_QuickMatchLan",
  "CS_QuickMatchCancel",
  "SC_QuickMatchCancel",
  "CS_ReplayList",
  "SC_ReplayList",
  "CS_ReplayChoose",
  "SC_ReplayChoose",
  "CS_ReplayStart",
  "SC_ReplayStart",
  "CS_ReplayEnd",
  "SC_ReplayEnd",
  "CS_QuickMatchClassType",
  "SC_QuickMatchClassType",
  "CS_TestProtocol",
  "SC_TestProtocol",
  "CS_Ping",
  "SC_Ping"
};
const std::map<int, const char*> _MessageId_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(86, _kMessageIdValues, _kMessageIdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


CSLogin::~CSLogin() throw() {
}


void CSLogin::__set_userName(const std::string& val) {
  this->userName = val;
}

void CSLogin::__set_password(const std::string& val) {
  this->password = val;
}

uint32_t CSLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSLogin");

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSLogin &a, CSLogin &b) {
  using ::std::swap;
  swap(a.userName, b.userName);
  swap(a.password, b.password);
  swap(a.__isset, b.__isset);
}

CSLogin::CSLogin(const CSLogin& other0) {
  userName = other0.userName;
  password = other0.password;
  __isset = other0.__isset;
}
CSLogin& CSLogin::operator=(const CSLogin& other1) {
  userName = other1.userName;
  password = other1.password;
  __isset = other1.__isset;
  return *this;
}
void CSLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSLogin(";
  out << "userName=" << to_string(userName);
  out << ", " << "password=" << to_string(password);
  out << ")";
}


SCLogin::~SCLogin() throw() {
}


void SCLogin::__set_result(const int32_t val) {
  this->result = val;
}

void SCLogin::__set_userData(const  ::CytxGame::UserData& val) {
  this->userData = val;
}

uint32_t SCLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userData.read(iprot);
          this->__isset.userData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCLogin");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->userData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCLogin &a, SCLogin &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.userData, b.userData);
  swap(a.__isset, b.__isset);
}

SCLogin::SCLogin(const SCLogin& other2) {
  result = other2.result;
  userData = other2.userData;
  __isset = other2.__isset;
}
SCLogin& SCLogin::operator=(const SCLogin& other3) {
  result = other3.result;
  userData = other3.userData;
  __isset = other3.__isset;
  return *this;
}
void SCLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCLogin(";
  out << "result=" << to_string(result);
  out << ", " << "userData=" << to_string(userData);
  out << ")";
}


CSRegister::~CSRegister() throw() {
}


void CSRegister::__set_userName(const std::string& val) {
  this->userName = val;
}

void CSRegister::__set_password(const std::string& val) {
  this->password = val;
}

uint32_t CSRegister::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRegister::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRegister");

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRegister &a, CSRegister &b) {
  using ::std::swap;
  swap(a.userName, b.userName);
  swap(a.password, b.password);
  swap(a.__isset, b.__isset);
}

CSRegister::CSRegister(const CSRegister& other4) {
  userName = other4.userName;
  password = other4.password;
  __isset = other4.__isset;
}
CSRegister& CSRegister::operator=(const CSRegister& other5) {
  userName = other5.userName;
  password = other5.password;
  __isset = other5.__isset;
  return *this;
}
void CSRegister::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRegister(";
  out << "userName=" << to_string(userName);
  out << ", " << "password=" << to_string(password);
  out << ")";
}


SCRegister::~SCRegister() throw() {
}


void SCRegister::__set_result(const int32_t val) {
  this->result = val;
}

void SCRegister::__set_userData(const  ::CytxGame::UserData& val) {
  this->userData = val;
}

uint32_t SCRegister::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userData.read(iprot);
          this->__isset.userData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRegister::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRegister");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->userData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRegister &a, SCRegister &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.userData, b.userData);
  swap(a.__isset, b.__isset);
}

SCRegister::SCRegister(const SCRegister& other6) {
  result = other6.result;
  userData = other6.userData;
  __isset = other6.__isset;
}
SCRegister& SCRegister::operator=(const SCRegister& other7) {
  result = other7.result;
  userData = other7.userData;
  __isset = other7.__isset;
  return *this;
}
void SCRegister::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRegister(";
  out << "result=" << to_string(result);
  out << ", " << "userData=" << to_string(userData);
  out << ")";
}


CSTouristLogin::~CSTouristLogin() throw() {
}


void CSTouristLogin::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

uint32_t CSTouristLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSTouristLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSTouristLogin");

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSTouristLogin &a, CSTouristLogin &b) {
  using ::std::swap;
  swap(a.deviceId, b.deviceId);
  swap(a.__isset, b.__isset);
}

CSTouristLogin::CSTouristLogin(const CSTouristLogin& other8) {
  deviceId = other8.deviceId;
  __isset = other8.__isset;
}
CSTouristLogin& CSTouristLogin::operator=(const CSTouristLogin& other9) {
  deviceId = other9.deviceId;
  __isset = other9.__isset;
  return *this;
}
void CSTouristLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSTouristLogin(";
  out << "deviceId=" << to_string(deviceId);
  out << ")";
}


SCTouristLogin::~SCTouristLogin() throw() {
}


void SCTouristLogin::__set_result(const int32_t val) {
  this->result = val;
}

void SCTouristLogin::__set_userData(const  ::CytxGame::UserData& val) {
  this->userData = val;
}

uint32_t SCTouristLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userData.read(iprot);
          this->__isset.userData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCTouristLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCTouristLogin");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->userData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCTouristLogin &a, SCTouristLogin &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.userData, b.userData);
  swap(a.__isset, b.__isset);
}

SCTouristLogin::SCTouristLogin(const SCTouristLogin& other10) {
  result = other10.result;
  userData = other10.userData;
  __isset = other10.__isset;
}
SCTouristLogin& SCTouristLogin::operator=(const SCTouristLogin& other11) {
  result = other11.result;
  userData = other11.userData;
  __isset = other11.__isset;
  return *this;
}
void SCTouristLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCTouristLogin(";
  out << "result=" << to_string(result);
  out << ", " << "userData=" << to_string(userData);
  out << ")";
}


CSLogout::~CSLogout() throw() {
}


uint32_t CSLogout::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSLogout::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSLogout");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSLogout &a, CSLogout &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSLogout::CSLogout(const CSLogout& other12) {
  (void) other12;
}
CSLogout& CSLogout::operator=(const CSLogout& other13) {
  (void) other13;
  return *this;
}
void CSLogout::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSLogout(";
  out << ")";
}


SCLogout::~SCLogout() throw() {
}


void SCLogout::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCLogout::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCLogout::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCLogout");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCLogout &a, SCLogout &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCLogout::SCLogout(const SCLogout& other14) {
  result = other14.result;
  __isset = other14.__isset;
}
SCLogout& SCLogout::operator=(const SCLogout& other15) {
  result = other15.result;
  __isset = other15.__isset;
  return *this;
}
void SCLogout::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCLogout(";
  out << "result=" << to_string(result);
  out << ")";
}


CLoginGame::~CLoginGame() throw() {
}


void CLoginGame::__set_accountId(const int32_t val) {
  this->accountId = val;
}

void CLoginGame::__set_sessionKey(const std::string& val) {
  this->sessionKey = val;
}

uint32_t CLoginGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->accountId);
          this->__isset.accountId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sessionKey);
          this->__isset.sessionKey = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CLoginGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CLoginGame");

  xfer += oprot->writeFieldBegin("accountId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->accountId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sessionKey", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->sessionKey);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CLoginGame &a, CLoginGame &b) {
  using ::std::swap;
  swap(a.accountId, b.accountId);
  swap(a.sessionKey, b.sessionKey);
  swap(a.__isset, b.__isset);
}

CLoginGame::CLoginGame(const CLoginGame& other16) {
  accountId = other16.accountId;
  sessionKey = other16.sessionKey;
  __isset = other16.__isset;
}
CLoginGame& CLoginGame::operator=(const CLoginGame& other17) {
  accountId = other17.accountId;
  sessionKey = other17.sessionKey;
  __isset = other17.__isset;
  return *this;
}
void CLoginGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CLoginGame(";
  out << "accountId=" << to_string(accountId);
  out << ", " << "sessionKey=" << to_string(sessionKey);
  out << ")";
}


SLoginGame::~SLoginGame() throw() {
}


void SLoginGame::__set_state(const bool val) {
  this->state = val;
}

void SLoginGame::__set_error(const std::string& val) {
  this->error = val;
__isset.error = true;
}

void SLoginGame::__set_account(const  ::CytxGame::AccountData& val) {
  this->account = val;
__isset.account = true;
}

uint32_t SLoginGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->error);
          this->__isset.error = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->account.read(iprot);
          this->__isset.account = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SLoginGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SLoginGame");

  xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->state);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.error) {
    xfer += oprot->writeFieldBegin("error", ::apache::thrift::protocol::T_STRING, 20);
    xfer += oprot->writeString(this->error);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.account) {
    xfer += oprot->writeFieldBegin("account", ::apache::thrift::protocol::T_STRUCT, 30);
    xfer += this->account.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SLoginGame &a, SLoginGame &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.error, b.error);
  swap(a.account, b.account);
  swap(a.__isset, b.__isset);
}

SLoginGame::SLoginGame(const SLoginGame& other18) {
  state = other18.state;
  error = other18.error;
  account = other18.account;
  __isset = other18.__isset;
}
SLoginGame& SLoginGame::operator=(const SLoginGame& other19) {
  state = other19.state;
  error = other19.error;
  account = other19.account;
  __isset = other19.__isset;
  return *this;
}
void SLoginGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SLoginGame(";
  out << "state=" << to_string(state);
  out << ", " << "error="; (__isset.error ? (out << to_string(error)) : (out << "<null>"));
  out << ", " << "account="; (__isset.account ? (out << to_string(account)) : (out << "<null>"));
  out << ")";
}


CSTouristLoginGame::~CSTouristLoginGame() throw() {
}


void CSTouristLoginGame::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

uint32_t CSTouristLoginGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSTouristLoginGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSTouristLoginGame");

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSTouristLoginGame &a, CSTouristLoginGame &b) {
  using ::std::swap;
  swap(a.deviceId, b.deviceId);
  swap(a.__isset, b.__isset);
}

CSTouristLoginGame::CSTouristLoginGame(const CSTouristLoginGame& other20) {
  deviceId = other20.deviceId;
  __isset = other20.__isset;
}
CSTouristLoginGame& CSTouristLoginGame::operator=(const CSTouristLoginGame& other21) {
  deviceId = other21.deviceId;
  __isset = other21.__isset;
  return *this;
}
void CSTouristLoginGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSTouristLoginGame(";
  out << "deviceId=" << to_string(deviceId);
  out << ")";
}


SCTouristLoginGame::~SCTouristLoginGame() throw() {
}


void SCTouristLoginGame::__set_result(const int32_t val) {
  this->result = val;
}

void SCTouristLoginGame::__set_userData(const  ::CytxGame::UserData& val) {
  this->userData = val;
}

uint32_t SCTouristLoginGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userData.read(iprot);
          this->__isset.userData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCTouristLoginGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCTouristLoginGame");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->userData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCTouristLoginGame &a, SCTouristLoginGame &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.userData, b.userData);
  swap(a.__isset, b.__isset);
}

SCTouristLoginGame::SCTouristLoginGame(const SCTouristLoginGame& other22) {
  result = other22.result;
  userData = other22.userData;
  __isset = other22.__isset;
}
SCTouristLoginGame& SCTouristLoginGame::operator=(const SCTouristLoginGame& other23) {
  result = other23.result;
  userData = other23.userData;
  __isset = other23.__isset;
  return *this;
}
void SCTouristLoginGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCTouristLoginGame(";
  out << "result=" << to_string(result);
  out << ", " << "userData=" << to_string(userData);
  out << ")";
}


CSCreateInstance::~CSCreateInstance() throw() {
}


void CSCreateInstance::__set_instanceName(const std::string& val) {
  this->instanceName = val;
}

uint32_t CSCreateInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instanceName);
          this->__isset.instanceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSCreateInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSCreateInstance");

  xfer += oprot->writeFieldBegin("instanceName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->instanceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSCreateInstance &a, CSCreateInstance &b) {
  using ::std::swap;
  swap(a.instanceName, b.instanceName);
  swap(a.__isset, b.__isset);
}

CSCreateInstance::CSCreateInstance(const CSCreateInstance& other24) {
  instanceName = other24.instanceName;
  __isset = other24.__isset;
}
CSCreateInstance& CSCreateInstance::operator=(const CSCreateInstance& other25) {
  instanceName = other25.instanceName;
  __isset = other25.__isset;
  return *this;
}
void CSCreateInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSCreateInstance(";
  out << "instanceName=" << to_string(instanceName);
  out << ")";
}


SCCreateInstance::~SCCreateInstance() throw() {
}


void SCCreateInstance::__set_result(const int32_t val) {
  this->result = val;
}

void SCCreateInstance::__set_instanceData(const  ::CytxGame::InstanceData& val) {
  this->instanceData = val;
}

uint32_t SCCreateInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->instanceData.read(iprot);
          this->__isset.instanceData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCCreateInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCCreateInstance");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instanceData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->instanceData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCCreateInstance &a, SCCreateInstance &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.instanceData, b.instanceData);
  swap(a.__isset, b.__isset);
}

SCCreateInstance::SCCreateInstance(const SCCreateInstance& other26) {
  result = other26.result;
  instanceData = other26.instanceData;
  __isset = other26.__isset;
}
SCCreateInstance& SCCreateInstance::operator=(const SCCreateInstance& other27) {
  result = other27.result;
  instanceData = other27.instanceData;
  __isset = other27.__isset;
  return *this;
}
void SCCreateInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCCreateInstance(";
  out << "result=" << to_string(result);
  out << ", " << "instanceData=" << to_string(instanceData);
  out << ")";
}


CSInstanceList::~CSInstanceList() throw() {
}


void CSInstanceList::__set_startIndex(const int32_t val) {
  this->startIndex = val;
}

void CSInstanceList::__set_count(const int32_t val) {
  this->count = val;
}

uint32_t CSInstanceList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startIndex);
          this->__isset.startIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSInstanceList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSInstanceList");

  xfer += oprot->writeFieldBegin("startIndex", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->startIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSInstanceList &a, CSInstanceList &b) {
  using ::std::swap;
  swap(a.startIndex, b.startIndex);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

CSInstanceList::CSInstanceList(const CSInstanceList& other28) {
  startIndex = other28.startIndex;
  count = other28.count;
  __isset = other28.__isset;
}
CSInstanceList& CSInstanceList::operator=(const CSInstanceList& other29) {
  startIndex = other29.startIndex;
  count = other29.count;
  __isset = other29.__isset;
  return *this;
}
void CSInstanceList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSInstanceList(";
  out << "startIndex=" << to_string(startIndex);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


SCInstanceList::~SCInstanceList() throw() {
}


void SCInstanceList::__set_result(const int32_t val) {
  this->result = val;
}

void SCInstanceList::__set_instanceList(const std::vector< ::CytxGame::InstanceData> & val) {
  this->instanceList = val;
}

uint32_t SCInstanceList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->instanceList.clear();
            uint32_t _size30;
            ::apache::thrift::protocol::TType _etype33;
            xfer += iprot->readListBegin(_etype33, _size30);
            this->instanceList.resize(_size30);
            uint32_t _i34;
            for (_i34 = 0; _i34 < _size30; ++_i34)
            {
              xfer += this->instanceList[_i34].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.instanceList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCInstanceList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCInstanceList");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instanceList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->instanceList.size()));
    std::vector< ::CytxGame::InstanceData> ::const_iterator _iter35;
    for (_iter35 = this->instanceList.begin(); _iter35 != this->instanceList.end(); ++_iter35)
    {
      xfer += (*_iter35).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCInstanceList &a, SCInstanceList &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.instanceList, b.instanceList);
  swap(a.__isset, b.__isset);
}

SCInstanceList::SCInstanceList(const SCInstanceList& other36) {
  result = other36.result;
  instanceList = other36.instanceList;
  __isset = other36.__isset;
}
SCInstanceList& SCInstanceList::operator=(const SCInstanceList& other37) {
  result = other37.result;
  instanceList = other37.instanceList;
  __isset = other37.__isset;
  return *this;
}
void SCInstanceList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCInstanceList(";
  out << "result=" << to_string(result);
  out << ", " << "instanceList=" << to_string(instanceList);
  out << ")";
}


CSJoinInstance::~CSJoinInstance() throw() {
}


void CSJoinInstance::__set_instanceId(const int32_t val) {
  this->instanceId = val;
}

void CSJoinInstance::__set_instanceName(const std::string& val) {
  this->instanceName = val;
}

uint32_t CSJoinInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->instanceId);
          this->__isset.instanceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->instanceName);
          this->__isset.instanceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSJoinInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSJoinInstance");

  xfer += oprot->writeFieldBegin("instanceId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->instanceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instanceName", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->instanceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSJoinInstance &a, CSJoinInstance &b) {
  using ::std::swap;
  swap(a.instanceId, b.instanceId);
  swap(a.instanceName, b.instanceName);
  swap(a.__isset, b.__isset);
}

CSJoinInstance::CSJoinInstance(const CSJoinInstance& other38) {
  instanceId = other38.instanceId;
  instanceName = other38.instanceName;
  __isset = other38.__isset;
}
CSJoinInstance& CSJoinInstance::operator=(const CSJoinInstance& other39) {
  instanceId = other39.instanceId;
  instanceName = other39.instanceName;
  __isset = other39.__isset;
  return *this;
}
void CSJoinInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSJoinInstance(";
  out << "instanceId=" << to_string(instanceId);
  out << ", " << "instanceName=" << to_string(instanceName);
  out << ")";
}


SCJoinInstance::~SCJoinInstance() throw() {
}


void SCJoinInstance::__set_result(const int32_t val) {
  this->result = val;
}

void SCJoinInstance::__set_instanceData(const  ::CytxGame::InstanceData& val) {
  this->instanceData = val;
}

uint32_t SCJoinInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->instanceData.read(iprot);
          this->__isset.instanceData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCJoinInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCJoinInstance");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("instanceData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->instanceData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCJoinInstance &a, SCJoinInstance &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.instanceData, b.instanceData);
  swap(a.__isset, b.__isset);
}

SCJoinInstance::SCJoinInstance(const SCJoinInstance& other40) {
  result = other40.result;
  instanceData = other40.instanceData;
  __isset = other40.__isset;
}
SCJoinInstance& SCJoinInstance::operator=(const SCJoinInstance& other41) {
  result = other41.result;
  instanceData = other41.instanceData;
  __isset = other41.__isset;
  return *this;
}
void SCJoinInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCJoinInstance(";
  out << "result=" << to_string(result);
  out << ", " << "instanceData=" << to_string(instanceData);
  out << ")";
}


CSExitInstance::~CSExitInstance() throw() {
}


uint32_t CSExitInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSExitInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSExitInstance");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSExitInstance &a, CSExitInstance &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSExitInstance::CSExitInstance(const CSExitInstance& other42) {
  (void) other42;
}
CSExitInstance& CSExitInstance::operator=(const CSExitInstance& other43) {
  (void) other43;
  return *this;
}
void CSExitInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSExitInstance(";
  out << ")";
}


SCExitInstance::~SCExitInstance() throw() {
}


void SCExitInstance::__set_result(const int32_t val) {
  this->result = val;
}

void SCExitInstance::__set_player(const  ::CytxGame::PlayerData& val) {
  this->player = val;
}

uint32_t SCExitInstance::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->player.read(iprot);
          this->__isset.player = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCExitInstance::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCExitInstance");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("player", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->player.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCExitInstance &a, SCExitInstance &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.player, b.player);
  swap(a.__isset, b.__isset);
}

SCExitInstance::SCExitInstance(const SCExitInstance& other44) {
  result = other44.result;
  player = other44.player;
  __isset = other44.__isset;
}
SCExitInstance& SCExitInstance::operator=(const SCExitInstance& other45) {
  result = other45.result;
  player = other45.player;
  __isset = other45.__isset;
  return *this;
}
void SCExitInstance::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCExitInstance(";
  out << "result=" << to_string(result);
  out << ", " << "player=" << to_string(player);
  out << ")";
}


CSStartGame::~CSStartGame() throw() {
}


void CSStartGame::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void CSStartGame::__set_isContinue(const bool val) {
  this->isContinue = val;
}

uint32_t CSStartGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isContinue);
          this->__isset.isContinue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSStartGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSStartGame");

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isContinue", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->isContinue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSStartGame &a, CSStartGame &b) {
  using ::std::swap;
  swap(a.levelId, b.levelId);
  swap(a.isContinue, b.isContinue);
  swap(a.__isset, b.__isset);
}

CSStartGame::CSStartGame(const CSStartGame& other46) {
  levelId = other46.levelId;
  isContinue = other46.isContinue;
  __isset = other46.__isset;
}
CSStartGame& CSStartGame::operator=(const CSStartGame& other47) {
  levelId = other47.levelId;
  isContinue = other47.isContinue;
  __isset = other47.__isset;
  return *this;
}
void CSStartGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSStartGame(";
  out << "levelId=" << to_string(levelId);
  out << ", " << "isContinue=" << to_string(isContinue);
  out << ")";
}


SCStartGame::~SCStartGame() throw() {
}


void SCStartGame::__set_result(const int32_t val) {
  this->result = val;
}

void SCStartGame::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void SCStartGame::__set_isContinue(const bool val) {
  this->isContinue = val;
}

void SCStartGame::__set_levelData(const  ::CytxGame::LevelData& val) {
  this->levelData = val;
}

uint32_t SCStartGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isContinue);
          this->__isset.isContinue = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCStartGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCStartGame");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isContinue", ::apache::thrift::protocol::T_BOOL, 25);
  xfer += oprot->writeBool(this->isContinue);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCStartGame &a, SCStartGame &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.levelId, b.levelId);
  swap(a.isContinue, b.isContinue);
  swap(a.levelData, b.levelData);
  swap(a.__isset, b.__isset);
}

SCStartGame::SCStartGame(const SCStartGame& other48) {
  result = other48.result;
  levelId = other48.levelId;
  isContinue = other48.isContinue;
  levelData = other48.levelData;
  __isset = other48.__isset;
}
SCStartGame& SCStartGame::operator=(const SCStartGame& other49) {
  result = other49.result;
  levelId = other49.levelId;
  isContinue = other49.isContinue;
  levelData = other49.levelData;
  __isset = other49.__isset;
  return *this;
}
void SCStartGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCStartGame(";
  out << "result=" << to_string(result);
  out << ", " << "levelId=" << to_string(levelId);
  out << ", " << "isContinue=" << to_string(isContinue);
  out << ", " << "levelData=" << to_string(levelData);
  out << ")";
}


CSStartGameConfirm::~CSStartGameConfirm() throw() {
}


uint32_t CSStartGameConfirm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSStartGameConfirm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSStartGameConfirm");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSStartGameConfirm &a, CSStartGameConfirm &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSStartGameConfirm::CSStartGameConfirm(const CSStartGameConfirm& other50) {
  (void) other50;
}
CSStartGameConfirm& CSStartGameConfirm::operator=(const CSStartGameConfirm& other51) {
  (void) other51;
  return *this;
}
void CSStartGameConfirm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSStartGameConfirm(";
  out << ")";
}


SCStartGameConfirm::~SCStartGameConfirm() throw() {
}


void SCStartGameConfirm::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCStartGameConfirm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCStartGameConfirm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCStartGameConfirm");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCStartGameConfirm &a, SCStartGameConfirm &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCStartGameConfirm::SCStartGameConfirm(const SCStartGameConfirm& other52) {
  result = other52.result;
  __isset = other52.__isset;
}
SCStartGameConfirm& SCStartGameConfirm::operator=(const SCStartGameConfirm& other53) {
  result = other53.result;
  __isset = other53.__isset;
  return *this;
}
void SCStartGameConfirm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCStartGameConfirm(";
  out << "result=" << to_string(result);
  out << ")";
}


CSEndGame::~CSEndGame() throw() {
}


void CSEndGame::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void CSEndGame::__set_levelData(const  ::CytxGame::LevelData& val) {
  this->levelData = val;
}

void CSEndGame::__set_isWin(const bool val) {
  this->isWin = val;
}

uint32_t CSEndGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isWin);
          this->__isset.isWin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSEndGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSEndGame");

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isWin", ::apache::thrift::protocol::T_BOOL, 30);
  xfer += oprot->writeBool(this->isWin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSEndGame &a, CSEndGame &b) {
  using ::std::swap;
  swap(a.levelId, b.levelId);
  swap(a.levelData, b.levelData);
  swap(a.isWin, b.isWin);
  swap(a.__isset, b.__isset);
}

CSEndGame::CSEndGame(const CSEndGame& other54) {
  levelId = other54.levelId;
  levelData = other54.levelData;
  isWin = other54.isWin;
  __isset = other54.__isset;
}
CSEndGame& CSEndGame::operator=(const CSEndGame& other55) {
  levelId = other55.levelId;
  levelData = other55.levelData;
  isWin = other55.isWin;
  __isset = other55.__isset;
  return *this;
}
void CSEndGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSEndGame(";
  out << "levelId=" << to_string(levelId);
  out << ", " << "levelData=" << to_string(levelData);
  out << ", " << "isWin=" << to_string(isWin);
  out << ")";
}


SCEndGame::~SCEndGame() throw() {
}


void SCEndGame::__set_result(const int32_t val) {
  this->result = val;
}

void SCEndGame::__set_endUserId(const int32_t val) {
  this->endUserId = val;
}

void SCEndGame::__set_isWin(const bool val) {
  this->isWin = val;
}

void SCEndGame::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void SCEndGame::__set_levelData(const  ::CytxGame::LevelData& val) {
  this->levelData = val;
}

uint32_t SCEndGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->endUserId);
          this->__isset.endUserId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isWin);
          this->__isset.isWin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCEndGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCEndGame");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endUserId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->endUserId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isWin", ::apache::thrift::protocol::T_BOOL, 30);
  xfer += oprot->writeBool(this->isWin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 50);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCEndGame &a, SCEndGame &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.endUserId, b.endUserId);
  swap(a.isWin, b.isWin);
  swap(a.levelId, b.levelId);
  swap(a.levelData, b.levelData);
  swap(a.__isset, b.__isset);
}

SCEndGame::SCEndGame(const SCEndGame& other56) {
  result = other56.result;
  endUserId = other56.endUserId;
  isWin = other56.isWin;
  levelId = other56.levelId;
  levelData = other56.levelData;
  __isset = other56.__isset;
}
SCEndGame& SCEndGame::operator=(const SCEndGame& other57) {
  result = other57.result;
  endUserId = other57.endUserId;
  isWin = other57.isWin;
  levelId = other57.levelId;
  levelData = other57.levelData;
  __isset = other57.__isset;
  return *this;
}
void SCEndGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCEndGame(";
  out << "result=" << to_string(result);
  out << ", " << "endUserId=" << to_string(endUserId);
  out << ", " << "isWin=" << to_string(isWin);
  out << ", " << "levelId=" << to_string(levelId);
  out << ", " << "levelData=" << to_string(levelData);
  out << ")";
}


CSExitGame::~CSExitGame() throw() {
}


uint32_t CSExitGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSExitGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSExitGame");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSExitGame &a, CSExitGame &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSExitGame::CSExitGame(const CSExitGame& other58) {
  (void) other58;
}
CSExitGame& CSExitGame::operator=(const CSExitGame& other59) {
  (void) other59;
  return *this;
}
void CSExitGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSExitGame(";
  out << ")";
}


SCExitGame::~SCExitGame() throw() {
}


void SCExitGame::__set_result(const int32_t val) {
  this->result = val;
}

void SCExitGame::__set_isNormalEnd(const bool val) {
  this->isNormalEnd = val;
}

uint32_t SCExitGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isNormalEnd);
          this->__isset.isNormalEnd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCExitGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCExitGame");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isNormalEnd", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->isNormalEnd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCExitGame &a, SCExitGame &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.isNormalEnd, b.isNormalEnd);
  swap(a.__isset, b.__isset);
}

SCExitGame::SCExitGame(const SCExitGame& other60) {
  result = other60.result;
  isNormalEnd = other60.isNormalEnd;
  __isset = other60.__isset;
}
SCExitGame& SCExitGame::operator=(const SCExitGame& other61) {
  result = other61.result;
  isNormalEnd = other61.isNormalEnd;
  __isset = other61.__isset;
  return *this;
}
void SCExitGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCExitGame(";
  out << "result=" << to_string(result);
  out << ", " << "isNormalEnd=" << to_string(isNormalEnd);
  out << ")";
}


CSRetrieveCommand::~CSRetrieveCommand() throw() {
}


void CSRetrieveCommand::__set_playerId(const int32_t val) {
  this->playerId = val;
}

void CSRetrieveCommand::__set_dataList(const std::vector< ::CytxGame::CommandData> & val) {
  this->dataList = val;
}

void CSRetrieveCommand::__set_timestamp(const double val) {
  this->timestamp = val;
}

uint32_t CSRetrieveCommand::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->playerId);
          this->__isset.playerId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataList.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _etype65;
            xfer += iprot->readListBegin(_etype65, _size62);
            this->dataList.resize(_size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              xfer += this->dataList[_i66].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->timestamp);
          this->__isset.timestamp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRetrieveCommand::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRetrieveCommand");

  xfer += oprot->writeFieldBegin("playerId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->playerId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dataList.size()));
    std::vector< ::CytxGame::CommandData> ::const_iterator _iter67;
    for (_iter67 = this->dataList.begin(); _iter67 != this->dataList.end(); ++_iter67)
    {
      xfer += (*_iter67).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timestamp", ::apache::thrift::protocol::T_DOUBLE, 30);
  xfer += oprot->writeDouble(this->timestamp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRetrieveCommand &a, CSRetrieveCommand &b) {
  using ::std::swap;
  swap(a.playerId, b.playerId);
  swap(a.dataList, b.dataList);
  swap(a.timestamp, b.timestamp);
  swap(a.__isset, b.__isset);
}

CSRetrieveCommand::CSRetrieveCommand(const CSRetrieveCommand& other68) {
  playerId = other68.playerId;
  dataList = other68.dataList;
  timestamp = other68.timestamp;
  __isset = other68.__isset;
}
CSRetrieveCommand& CSRetrieveCommand::operator=(const CSRetrieveCommand& other69) {
  playerId = other69.playerId;
  dataList = other69.dataList;
  timestamp = other69.timestamp;
  __isset = other69.__isset;
  return *this;
}
void CSRetrieveCommand::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRetrieveCommand(";
  out << "playerId=" << to_string(playerId);
  out << ", " << "dataList=" << to_string(dataList);
  out << ", " << "timestamp=" << to_string(timestamp);
  out << ")";
}


SCRetrieveCommand::~SCRetrieveCommand() throw() {
}


void SCRetrieveCommand::__set_dataList(const std::vector< ::CytxGame::CommandData> & val) {
  this->dataList = val;
}

uint32_t SCRetrieveCommand::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->dataList.clear();
            uint32_t _size70;
            ::apache::thrift::protocol::TType _etype73;
            xfer += iprot->readListBegin(_etype73, _size70);
            this->dataList.resize(_size70);
            uint32_t _i74;
            for (_i74 = 0; _i74 < _size70; ++_i74)
            {
              xfer += this->dataList[_i74].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.dataList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRetrieveCommand::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRetrieveCommand");

  xfer += oprot->writeFieldBegin("dataList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dataList.size()));
    std::vector< ::CytxGame::CommandData> ::const_iterator _iter75;
    for (_iter75 = this->dataList.begin(); _iter75 != this->dataList.end(); ++_iter75)
    {
      xfer += (*_iter75).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRetrieveCommand &a, SCRetrieveCommand &b) {
  using ::std::swap;
  swap(a.dataList, b.dataList);
  swap(a.__isset, b.__isset);
}

SCRetrieveCommand::SCRetrieveCommand(const SCRetrieveCommand& other76) {
  dataList = other76.dataList;
  __isset = other76.__isset;
}
SCRetrieveCommand& SCRetrieveCommand::operator=(const SCRetrieveCommand& other77) {
  dataList = other77.dataList;
  __isset = other77.__isset;
  return *this;
}
void SCRetrieveCommand::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRetrieveCommand(";
  out << "dataList=" << to_string(dataList);
  out << ")";
}


CSFrame::~CSFrame() throw() {
}


void CSFrame::__set_frameData(const  ::CytxGame::FrameData& val) {
  this->frameData = val;
}

uint32_t CSFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frameData.read(iprot);
          this->__isset.frameData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSFrame");

  xfer += oprot->writeFieldBegin("frameData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->frameData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSFrame &a, CSFrame &b) {
  using ::std::swap;
  swap(a.frameData, b.frameData);
  swap(a.__isset, b.__isset);
}

CSFrame::CSFrame(const CSFrame& other78) {
  frameData = other78.frameData;
  __isset = other78.__isset;
}
CSFrame& CSFrame::operator=(const CSFrame& other79) {
  frameData = other79.frameData;
  __isset = other79.__isset;
  return *this;
}
void CSFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSFrame(";
  out << "frameData=" << to_string(frameData);
  out << ")";
}


SCFrame::~SCFrame() throw() {
}


void SCFrame::__set_frameData(const  ::CytxGame::FrameData& val) {
  this->frameData = val;
}

uint32_t SCFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frameData.read(iprot);
          this->__isset.frameData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCFrame");

  xfer += oprot->writeFieldBegin("frameData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->frameData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCFrame &a, SCFrame &b) {
  using ::std::swap;
  swap(a.frameData, b.frameData);
  swap(a.__isset, b.__isset);
}

SCFrame::SCFrame(const SCFrame& other80) {
  frameData = other80.frameData;
  __isset = other80.__isset;
}
SCFrame& SCFrame::operator=(const SCFrame& other81) {
  frameData = other81.frameData;
  __isset = other81.__isset;
  return *this;
}
void SCFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCFrame(";
  out << "frameData=" << to_string(frameData);
  out << ")";
}


CSRandomNickname::~CSRandomNickname() throw() {
}


uint32_t CSRandomNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRandomNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRandomNickname");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRandomNickname &a, CSRandomNickname &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSRandomNickname::CSRandomNickname(const CSRandomNickname& other82) {
  (void) other82;
}
CSRandomNickname& CSRandomNickname::operator=(const CSRandomNickname& other83) {
  (void) other83;
  return *this;
}
void CSRandomNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRandomNickname(";
  out << ")";
}


SCRandomNickname::~SCRandomNickname() throw() {
}


void SCRandomNickname::__set_result(const int32_t val) {
  this->result = val;
}

void SCRandomNickname::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t SCRandomNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRandomNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRandomNickname");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRandomNickname &a, SCRandomNickname &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

SCRandomNickname::SCRandomNickname(const SCRandomNickname& other84) {
  result = other84.result;
  nickname = other84.nickname;
  __isset = other84.__isset;
}
SCRandomNickname& SCRandomNickname::operator=(const SCRandomNickname& other85) {
  result = other85.result;
  nickname = other85.nickname;
  __isset = other85.__isset;
  return *this;
}
void SCRandomNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRandomNickname(";
  out << "result=" << to_string(result);
  out << ", " << "nickname=" << to_string(nickname);
  out << ")";
}


CSSetNickname::~CSSetNickname() throw() {
}


void CSSetNickname::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t CSSetNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSetNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSetNickname");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSetNickname &a, CSSetNickname &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

CSSetNickname::CSSetNickname(const CSSetNickname& other86) {
  nickname = other86.nickname;
  __isset = other86.__isset;
}
CSSetNickname& CSSetNickname::operator=(const CSSetNickname& other87) {
  nickname = other87.nickname;
  __isset = other87.__isset;
  return *this;
}
void CSSetNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSetNickname(";
  out << "nickname=" << to_string(nickname);
  out << ")";
}


SCSetNickname::~SCSetNickname() throw() {
}


void SCSetNickname::__set_result(const int32_t val) {
  this->result = val;
}

void SCSetNickname::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t SCSetNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSetNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSetNickname");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSetNickname &a, SCSetNickname &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

SCSetNickname::SCSetNickname(const SCSetNickname& other88) {
  result = other88.result;
  nickname = other88.nickname;
  __isset = other88.__isset;
}
SCSetNickname& SCSetNickname::operator=(const SCSetNickname& other89) {
  result = other89.result;
  nickname = other89.nickname;
  __isset = other89.__isset;
  return *this;
}
void SCSetNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSetNickname(";
  out << "result=" << to_string(result);
  out << ", " << "nickname=" << to_string(nickname);
  out << ")";
}


CSSetClassType::~CSSetClassType() throw() {
}


void CSSetClassType::__set_classType(const  ::CytxGame::ClassType::type val) {
  this->classType = val;
}

uint32_t CSSetClassType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast90;
          xfer += iprot->readI32(ecast90);
          this->classType = ( ::CytxGame::ClassType::type)ecast90;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSetClassType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSetClassType");

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSetClassType &a, CSSetClassType &b) {
  using ::std::swap;
  swap(a.classType, b.classType);
  swap(a.__isset, b.__isset);
}

CSSetClassType::CSSetClassType(const CSSetClassType& other91) {
  classType = other91.classType;
  __isset = other91.__isset;
}
CSSetClassType& CSSetClassType::operator=(const CSSetClassType& other92) {
  classType = other92.classType;
  __isset = other92.__isset;
  return *this;
}
void CSSetClassType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSetClassType(";
  out << "classType=" << to_string(classType);
  out << ")";
}


SCSetClassType::~SCSetClassType() throw() {
}


void SCSetClassType::__set_result(const int32_t val) {
  this->result = val;
}

void SCSetClassType::__set_classType(const  ::CytxGame::ClassType::type val) {
  this->classType = val;
}

uint32_t SCSetClassType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast93;
          xfer += iprot->readI32(ecast93);
          this->classType = ( ::CytxGame::ClassType::type)ecast93;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSetClassType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSetClassType");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSetClassType &a, SCSetClassType &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.classType, b.classType);
  swap(a.__isset, b.__isset);
}

SCSetClassType::SCSetClassType(const SCSetClassType& other94) {
  result = other94.result;
  classType = other94.classType;
  __isset = other94.__isset;
}
SCSetClassType& SCSetClassType::operator=(const SCSetClassType& other95) {
  result = other95.result;
  classType = other95.classType;
  __isset = other95.__isset;
  return *this;
}
void SCSetClassType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSetClassType(";
  out << "result=" << to_string(result);
  out << ", " << "classType=" << to_string(classType);
  out << ")";
}


CSRefreshFriendList::~CSRefreshFriendList() throw() {
}


uint32_t CSRefreshFriendList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRefreshFriendList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRefreshFriendList");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRefreshFriendList &a, CSRefreshFriendList &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSRefreshFriendList::CSRefreshFriendList(const CSRefreshFriendList& other96) {
  (void) other96;
}
CSRefreshFriendList& CSRefreshFriendList::operator=(const CSRefreshFriendList& other97) {
  (void) other97;
  return *this;
}
void CSRefreshFriendList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRefreshFriendList(";
  out << ")";
}


SCRefreshFriendList::~SCRefreshFriendList() throw() {
}


void SCRefreshFriendList::__set_result(const int32_t val) {
  this->result = val;
}

void SCRefreshFriendList::__set_playerMap(const std::map<int32_t,  ::CytxGame::PlayerData> & val) {
  this->playerMap = val;
}

uint32_t SCRefreshFriendList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->playerMap.clear();
            uint32_t _size98;
            ::apache::thrift::protocol::TType _ktype99;
            ::apache::thrift::protocol::TType _vtype100;
            xfer += iprot->readMapBegin(_ktype99, _vtype100, _size98);
            uint32_t _i102;
            for (_i102 = 0; _i102 < _size98; ++_i102)
            {
              int32_t _key103;
              xfer += iprot->readI32(_key103);
               ::CytxGame::PlayerData& _val104 = this->playerMap[_key103];
              xfer += _val104.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.playerMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRefreshFriendList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRefreshFriendList");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerMap", ::apache::thrift::protocol::T_MAP, 20);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerMap.size()));
    std::map<int32_t,  ::CytxGame::PlayerData> ::const_iterator _iter105;
    for (_iter105 = this->playerMap.begin(); _iter105 != this->playerMap.end(); ++_iter105)
    {
      xfer += oprot->writeI32(_iter105->first);
      xfer += _iter105->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRefreshFriendList &a, SCRefreshFriendList &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.playerMap, b.playerMap);
  swap(a.__isset, b.__isset);
}

SCRefreshFriendList::SCRefreshFriendList(const SCRefreshFriendList& other106) {
  result = other106.result;
  playerMap = other106.playerMap;
  __isset = other106.__isset;
}
SCRefreshFriendList& SCRefreshFriendList::operator=(const SCRefreshFriendList& other107) {
  result = other107.result;
  playerMap = other107.playerMap;
  __isset = other107.__isset;
  return *this;
}
void SCRefreshFriendList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRefreshFriendList(";
  out << "result=" << to_string(result);
  out << ", " << "playerMap=" << to_string(playerMap);
  out << ")";
}


CSInvitation::~CSInvitation() throw() {
}


void CSInvitation::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t CSInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSInvitation");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSInvitation &a, CSInvitation &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

CSInvitation::CSInvitation(const CSInvitation& other108) {
  nickname = other108.nickname;
  __isset = other108.__isset;
}
CSInvitation& CSInvitation::operator=(const CSInvitation& other109) {
  nickname = other109.nickname;
  __isset = other109.__isset;
  return *this;
}
void CSInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSInvitation(";
  out << "nickname=" << to_string(nickname);
  out << ")";
}


SCInvitation::~SCInvitation() throw() {
}


void SCInvitation::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCInvitation");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCInvitation &a, SCInvitation &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCInvitation::SCInvitation(const SCInvitation& other110) {
  result = other110.result;
  __isset = other110.__isset;
}
SCInvitation& SCInvitation::operator=(const SCInvitation& other111) {
  result = other111.result;
  __isset = other111.__isset;
  return *this;
}
void SCInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCInvitation(";
  out << "result=" << to_string(result);
  out << ")";
}


SCNoticeInvitation::~SCNoticeInvitation() throw() {
}


void SCNoticeInvitation::__set_roleData(const  ::CytxGame::RoleData& val) {
  this->roleData = val;
}

uint32_t SCNoticeInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->roleData.read(iprot);
          this->__isset.roleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCNoticeInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCNoticeInvitation");

  xfer += oprot->writeFieldBegin("roleData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->roleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCNoticeInvitation &a, SCNoticeInvitation &b) {
  using ::std::swap;
  swap(a.roleData, b.roleData);
  swap(a.__isset, b.__isset);
}

SCNoticeInvitation::SCNoticeInvitation(const SCNoticeInvitation& other112) {
  roleData = other112.roleData;
  __isset = other112.__isset;
}
SCNoticeInvitation& SCNoticeInvitation::operator=(const SCNoticeInvitation& other113) {
  roleData = other113.roleData;
  __isset = other113.__isset;
  return *this;
}
void SCNoticeInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCNoticeInvitation(";
  out << "roleData=" << to_string(roleData);
  out << ")";
}


CSConfirmInvitation::~CSConfirmInvitation() throw() {
}


uint32_t CSConfirmInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSConfirmInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSConfirmInvitation");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSConfirmInvitation &a, CSConfirmInvitation &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSConfirmInvitation::CSConfirmInvitation(const CSConfirmInvitation& other114) {
  (void) other114;
}
CSConfirmInvitation& CSConfirmInvitation::operator=(const CSConfirmInvitation& other115) {
  (void) other115;
  return *this;
}
void CSConfirmInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSConfirmInvitation(";
  out << ")";
}


SCConfirmInvitation::~SCConfirmInvitation() throw() {
}


void SCConfirmInvitation::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCConfirmInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCConfirmInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCConfirmInvitation");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCConfirmInvitation &a, SCConfirmInvitation &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCConfirmInvitation::SCConfirmInvitation(const SCConfirmInvitation& other116) {
  result = other116.result;
  __isset = other116.__isset;
}
SCConfirmInvitation& SCConfirmInvitation::operator=(const SCConfirmInvitation& other117) {
  result = other117.result;
  __isset = other117.__isset;
  return *this;
}
void SCConfirmInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCConfirmInvitation(";
  out << "result=" << to_string(result);
  out << ")";
}


SCNoticeConfirmInvitation::~SCNoticeConfirmInvitation() throw() {
}


void SCNoticeConfirmInvitation::__set_roleData(const  ::CytxGame::RoleData& val) {
  this->roleData = val;
}

uint32_t SCNoticeConfirmInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->roleData.read(iprot);
          this->__isset.roleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCNoticeConfirmInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCNoticeConfirmInvitation");

  xfer += oprot->writeFieldBegin("roleData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->roleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCNoticeConfirmInvitation &a, SCNoticeConfirmInvitation &b) {
  using ::std::swap;
  swap(a.roleData, b.roleData);
  swap(a.__isset, b.__isset);
}

SCNoticeConfirmInvitation::SCNoticeConfirmInvitation(const SCNoticeConfirmInvitation& other118) {
  roleData = other118.roleData;
  __isset = other118.__isset;
}
SCNoticeConfirmInvitation& SCNoticeConfirmInvitation::operator=(const SCNoticeConfirmInvitation& other119) {
  roleData = other119.roleData;
  __isset = other119.__isset;
  return *this;
}
void SCNoticeConfirmInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCNoticeConfirmInvitation(";
  out << "roleData=" << to_string(roleData);
  out << ")";
}


CSCancelInvitation::~CSCancelInvitation() throw() {
}


uint32_t CSCancelInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSCancelInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSCancelInvitation");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSCancelInvitation &a, CSCancelInvitation &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSCancelInvitation::CSCancelInvitation(const CSCancelInvitation& other120) {
  (void) other120;
}
CSCancelInvitation& CSCancelInvitation::operator=(const CSCancelInvitation& other121) {
  (void) other121;
  return *this;
}
void CSCancelInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSCancelInvitation(";
  out << ")";
}


SCCancelInvitation::~SCCancelInvitation() throw() {
}


void SCCancelInvitation::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCCancelInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCCancelInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCCancelInvitation");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCCancelInvitation &a, SCCancelInvitation &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCCancelInvitation::SCCancelInvitation(const SCCancelInvitation& other122) {
  result = other122.result;
  __isset = other122.__isset;
}
SCCancelInvitation& SCCancelInvitation::operator=(const SCCancelInvitation& other123) {
  result = other123.result;
  __isset = other123.__isset;
  return *this;
}
void SCCancelInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCCancelInvitation(";
  out << "result=" << to_string(result);
  out << ")";
}


SCNoticeCancelInvitation::~SCNoticeCancelInvitation() throw() {
}


void SCNoticeCancelInvitation::__set_roleData(const  ::CytxGame::RoleData& val) {
  this->roleData = val;
}

uint32_t SCNoticeCancelInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->roleData.read(iprot);
          this->__isset.roleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCNoticeCancelInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCNoticeCancelInvitation");

  xfer += oprot->writeFieldBegin("roleData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->roleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCNoticeCancelInvitation &a, SCNoticeCancelInvitation &b) {
  using ::std::swap;
  swap(a.roleData, b.roleData);
  swap(a.__isset, b.__isset);
}

SCNoticeCancelInvitation::SCNoticeCancelInvitation(const SCNoticeCancelInvitation& other124) {
  roleData = other124.roleData;
  __isset = other124.__isset;
}
SCNoticeCancelInvitation& SCNoticeCancelInvitation::operator=(const SCNoticeCancelInvitation& other125) {
  roleData = other125.roleData;
  __isset = other125.__isset;
  return *this;
}
void SCNoticeCancelInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCNoticeCancelInvitation(";
  out << "roleData=" << to_string(roleData);
  out << ")";
}


CSExitInvitation::~CSExitInvitation() throw() {
}


uint32_t CSExitInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSExitInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSExitInvitation");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSExitInvitation &a, CSExitInvitation &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSExitInvitation::CSExitInvitation(const CSExitInvitation& other126) {
  (void) other126;
}
CSExitInvitation& CSExitInvitation::operator=(const CSExitInvitation& other127) {
  (void) other127;
  return *this;
}
void CSExitInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSExitInvitation(";
  out << ")";
}


SCExitInvitation::~SCExitInvitation() throw() {
}


void SCExitInvitation::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCExitInvitation::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCExitInvitation::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCExitInvitation");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCExitInvitation &a, SCExitInvitation &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCExitInvitation::SCExitInvitation(const SCExitInvitation& other128) {
  result = other128.result;
  __isset = other128.__isset;
}
SCExitInvitation& SCExitInvitation::operator=(const SCExitInvitation& other129) {
  result = other129.result;
  __isset = other129.__isset;
  return *this;
}
void SCExitInvitation::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCExitInvitation(";
  out << "result=" << to_string(result);
  out << ")";
}


CSChooseLevel::~CSChooseLevel() throw() {
}


void CSChooseLevel::__set_levelId(const int32_t val) {
  this->levelId = val;
}

uint32_t CSChooseLevel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSChooseLevel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSChooseLevel");

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSChooseLevel &a, CSChooseLevel &b) {
  using ::std::swap;
  swap(a.levelId, b.levelId);
  swap(a.__isset, b.__isset);
}

CSChooseLevel::CSChooseLevel(const CSChooseLevel& other130) {
  levelId = other130.levelId;
  __isset = other130.__isset;
}
CSChooseLevel& CSChooseLevel::operator=(const CSChooseLevel& other131) {
  levelId = other131.levelId;
  __isset = other131.__isset;
  return *this;
}
void CSChooseLevel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSChooseLevel(";
  out << "levelId=" << to_string(levelId);
  out << ")";
}


SCChooseLevel::~SCChooseLevel() throw() {
}


void SCChooseLevel::__set_result(const int32_t val) {
  this->result = val;
}

void SCChooseLevel::__set_levelId(const int32_t val) {
  this->levelId = val;
}

uint32_t SCChooseLevel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCChooseLevel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCChooseLevel");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCChooseLevel &a, SCChooseLevel &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.levelId, b.levelId);
  swap(a.__isset, b.__isset);
}

SCChooseLevel::SCChooseLevel(const SCChooseLevel& other132) {
  result = other132.result;
  levelId = other132.levelId;
  __isset = other132.__isset;
}
SCChooseLevel& SCChooseLevel::operator=(const SCChooseLevel& other133) {
  result = other133.result;
  levelId = other133.levelId;
  __isset = other133.__isset;
  return *this;
}
void SCChooseLevel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCChooseLevel(";
  out << "result=" << to_string(result);
  out << ", " << "levelId=" << to_string(levelId);
  out << ")";
}


CSFindUser::~CSFindUser() throw() {
}


void CSFindUser::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t CSFindUser::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSFindUser::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSFindUser");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSFindUser &a, CSFindUser &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

CSFindUser::CSFindUser(const CSFindUser& other134) {
  nickname = other134.nickname;
  __isset = other134.__isset;
}
CSFindUser& CSFindUser::operator=(const CSFindUser& other135) {
  nickname = other135.nickname;
  __isset = other135.__isset;
  return *this;
}
void CSFindUser::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSFindUser(";
  out << "nickname=" << to_string(nickname);
  out << ")";
}


SCFindUser::~SCFindUser() throw() {
}


void SCFindUser::__set_result(const int32_t val) {
  this->result = val;
}

void SCFindUser::__set_player(const  ::CytxGame::PlayerData& val) {
  this->player = val;
}

uint32_t SCFindUser::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->player.read(iprot);
          this->__isset.player = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCFindUser::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCFindUser");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("player", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->player.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCFindUser &a, SCFindUser &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.player, b.player);
  swap(a.__isset, b.__isset);
}

SCFindUser::SCFindUser(const SCFindUser& other136) {
  result = other136.result;
  player = other136.player;
  __isset = other136.__isset;
}
SCFindUser& SCFindUser::operator=(const SCFindUser& other137) {
  result = other137.result;
  player = other137.player;
  __isset = other137.__isset;
  return *this;
}
void SCFindUser::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCFindUser(";
  out << "result=" << to_string(result);
  out << ", " << "player=" << to_string(player);
  out << ")";
}


CSSaveDungeonProgress::~CSSaveDungeonProgress() throw() {
}


void CSSaveDungeonProgress::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void CSSaveDungeonProgress::__set_levelData(const  ::CytxGame::LevelData& val) {
  this->levelData = val;
}

uint32_t CSSaveDungeonProgress::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSaveDungeonProgress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSaveDungeonProgress");

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSaveDungeonProgress &a, CSSaveDungeonProgress &b) {
  using ::std::swap;
  swap(a.levelId, b.levelId);
  swap(a.levelData, b.levelData);
  swap(a.__isset, b.__isset);
}

CSSaveDungeonProgress::CSSaveDungeonProgress(const CSSaveDungeonProgress& other138) {
  levelId = other138.levelId;
  levelData = other138.levelData;
  __isset = other138.__isset;
}
CSSaveDungeonProgress& CSSaveDungeonProgress::operator=(const CSSaveDungeonProgress& other139) {
  levelId = other139.levelId;
  levelData = other139.levelData;
  __isset = other139.__isset;
  return *this;
}
void CSSaveDungeonProgress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSaveDungeonProgress(";
  out << "levelId=" << to_string(levelId);
  out << ", " << "levelData=" << to_string(levelData);
  out << ")";
}


SCSaveDungeonProgress::~SCSaveDungeonProgress() throw() {
}


void SCSaveDungeonProgress::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCSaveDungeonProgress::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSaveDungeonProgress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSaveDungeonProgress");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSaveDungeonProgress &a, SCSaveDungeonProgress &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCSaveDungeonProgress::SCSaveDungeonProgress(const SCSaveDungeonProgress& other140) {
  result = other140.result;
  __isset = other140.__isset;
}
SCSaveDungeonProgress& SCSaveDungeonProgress::operator=(const SCSaveDungeonProgress& other141) {
  result = other141.result;
  __isset = other141.__isset;
  return *this;
}
void SCSaveDungeonProgress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSaveDungeonProgress(";
  out << "result=" << to_string(result);
  out << ")";
}


CSPause::~CSPause() throw() {
}


uint32_t CSPause::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSPause::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSPause");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSPause &a, CSPause &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSPause::CSPause(const CSPause& other142) {
  (void) other142;
}
CSPause& CSPause::operator=(const CSPause& other143) {
  (void) other143;
  return *this;
}
void CSPause::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSPause(";
  out << ")";
}


SCPause::~SCPause() throw() {
}


void SCPause::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCPause::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCPause::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCPause");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCPause &a, SCPause &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCPause::SCPause(const SCPause& other144) {
  result = other144.result;
  __isset = other144.__isset;
}
SCPause& SCPause::operator=(const SCPause& other145) {
  result = other145.result;
  __isset = other145.__isset;
  return *this;
}
void SCPause::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCPause(";
  out << "result=" << to_string(result);
  out << ")";
}


CSContinue::~CSContinue() throw() {
}


uint32_t CSContinue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSContinue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSContinue");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSContinue &a, CSContinue &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSContinue::CSContinue(const CSContinue& other146) {
  (void) other146;
}
CSContinue& CSContinue::operator=(const CSContinue& other147) {
  (void) other147;
  return *this;
}
void CSContinue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSContinue(";
  out << ")";
}


SCContinue::~SCContinue() throw() {
}


void SCContinue::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCContinue::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCContinue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCContinue");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCContinue &a, SCContinue &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCContinue::SCContinue(const SCContinue& other148) {
  result = other148.result;
  __isset = other148.__isset;
}
SCContinue& SCContinue::operator=(const SCContinue& other149) {
  result = other149.result;
  __isset = other149.__isset;
  return *this;
}
void SCContinue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCContinue(";
  out << "result=" << to_string(result);
  out << ")";
}


CSRestartGame::~CSRestartGame() throw() {
}


uint32_t CSRestartGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRestartGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRestartGame");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRestartGame &a, CSRestartGame &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSRestartGame::CSRestartGame(const CSRestartGame& other150) {
  (void) other150;
}
CSRestartGame& CSRestartGame::operator=(const CSRestartGame& other151) {
  (void) other151;
  return *this;
}
void CSRestartGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRestartGame(";
  out << ")";
}


SCRestartGame::~SCRestartGame() throw() {
}


void SCRestartGame::__set_result(const int32_t val) {
  this->result = val;
}

void SCRestartGame::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void SCRestartGame::__set_levelData(const  ::CytxGame::LevelData& val) {
  this->levelData = val;
}

uint32_t SCRestartGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRestartGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRestartGame");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRestartGame &a, SCRestartGame &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.levelId, b.levelId);
  swap(a.levelData, b.levelData);
  swap(a.__isset, b.__isset);
}

SCRestartGame::SCRestartGame(const SCRestartGame& other152) {
  result = other152.result;
  levelId = other152.levelId;
  levelData = other152.levelData;
  __isset = other152.__isset;
}
SCRestartGame& SCRestartGame::operator=(const SCRestartGame& other153) {
  result = other153.result;
  levelId = other153.levelId;
  levelData = other153.levelData;
  __isset = other153.__isset;
  return *this;
}
void SCRestartGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRestartGame(";
  out << "result=" << to_string(result);
  out << ", " << "levelId=" << to_string(levelId);
  out << ", " << "levelData=" << to_string(levelData);
  out << ")";
}


CSQuickMatch::~CSQuickMatch() throw() {
}


void CSQuickMatch::__set_userId(const int32_t val) {
  this->userId = val;
}

uint32_t CSQuickMatch::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSQuickMatch::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSQuickMatch");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSQuickMatch &a, CSQuickMatch &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.__isset, b.__isset);
}

CSQuickMatch::CSQuickMatch(const CSQuickMatch& other154) {
  userId = other154.userId;
  __isset = other154.__isset;
}
CSQuickMatch& CSQuickMatch::operator=(const CSQuickMatch& other155) {
  userId = other155.userId;
  __isset = other155.__isset;
  return *this;
}
void CSQuickMatch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSQuickMatch(";
  out << "userId=" << to_string(userId);
  out << ")";
}


SCQuickMatch::~SCQuickMatch() throw() {
}


void SCQuickMatch::__set_result(const int32_t val) {
  this->result = val;
}

void SCQuickMatch::__set_isHostRole(const bool val) {
  this->isHostRole = val;
}

void SCQuickMatch::__set_hostRoleData(const  ::CytxGame::RoleData& val) {
  this->hostRoleData = val;
}

void SCQuickMatch::__set_guestRoleData(const  ::CytxGame::RoleData& val) {
  this->guestRoleData = val;
}

uint32_t SCQuickMatch::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isHostRole);
          this->__isset.isHostRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hostRoleData.read(iprot);
          this->__isset.hostRoleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->guestRoleData.read(iprot);
          this->__isset.guestRoleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCQuickMatch::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCQuickMatch");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isHostRole", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->isHostRole);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostRoleData", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->hostRoleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guestRoleData", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->guestRoleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCQuickMatch &a, SCQuickMatch &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.isHostRole, b.isHostRole);
  swap(a.hostRoleData, b.hostRoleData);
  swap(a.guestRoleData, b.guestRoleData);
  swap(a.__isset, b.__isset);
}

SCQuickMatch::SCQuickMatch(const SCQuickMatch& other156) {
  result = other156.result;
  isHostRole = other156.isHostRole;
  hostRoleData = other156.hostRoleData;
  guestRoleData = other156.guestRoleData;
  __isset = other156.__isset;
}
SCQuickMatch& SCQuickMatch::operator=(const SCQuickMatch& other157) {
  result = other157.result;
  isHostRole = other157.isHostRole;
  hostRoleData = other157.hostRoleData;
  guestRoleData = other157.guestRoleData;
  __isset = other157.__isset;
  return *this;
}
void SCQuickMatch::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCQuickMatch(";
  out << "result=" << to_string(result);
  out << ", " << "isHostRole=" << to_string(isHostRole);
  out << ", " << "hostRoleData=" << to_string(hostRoleData);
  out << ", " << "guestRoleData=" << to_string(guestRoleData);
  out << ")";
}


CSQuickMatchLan::~CSQuickMatchLan() throw() {
}


void CSQuickMatchLan::__set_userId(const std::vector<int32_t> & val) {
  this->userId = val;
}

uint32_t CSQuickMatchLan::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->userId.clear();
            uint32_t _size158;
            ::apache::thrift::protocol::TType _etype161;
            xfer += iprot->readListBegin(_etype161, _size158);
            this->userId.resize(_size158);
            uint32_t _i162;
            for (_i162 = 0; _i162 < _size158; ++_i162)
            {
              xfer += iprot->readI32(this->userId[_i162]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSQuickMatchLan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSQuickMatchLan");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->userId.size()));
    std::vector<int32_t> ::const_iterator _iter163;
    for (_iter163 = this->userId.begin(); _iter163 != this->userId.end(); ++_iter163)
    {
      xfer += oprot->writeI32((*_iter163));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSQuickMatchLan &a, CSQuickMatchLan &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.__isset, b.__isset);
}

CSQuickMatchLan::CSQuickMatchLan(const CSQuickMatchLan& other164) {
  userId = other164.userId;
  __isset = other164.__isset;
}
CSQuickMatchLan& CSQuickMatchLan::operator=(const CSQuickMatchLan& other165) {
  userId = other165.userId;
  __isset = other165.__isset;
  return *this;
}
void CSQuickMatchLan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSQuickMatchLan(";
  out << "userId=" << to_string(userId);
  out << ")";
}


SCQuickMatchLan::~SCQuickMatchLan() throw() {
}


void SCQuickMatchLan::__set_result(const int32_t val) {
  this->result = val;
}

void SCQuickMatchLan::__set_isHostRole(const bool val) {
  this->isHostRole = val;
}

void SCQuickMatchLan::__set_hostRoleData(const  ::CytxGame::RoleData& val) {
  this->hostRoleData = val;
}

void SCQuickMatchLan::__set_guestRoleData(const  ::CytxGame::RoleData& val) {
  this->guestRoleData = val;
}

uint32_t SCQuickMatchLan::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isHostRole);
          this->__isset.isHostRole = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->hostRoleData.read(iprot);
          this->__isset.hostRoleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->guestRoleData.read(iprot);
          this->__isset.guestRoleData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCQuickMatchLan::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCQuickMatchLan");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isHostRole", ::apache::thrift::protocol::T_BOOL, 20);
  xfer += oprot->writeBool(this->isHostRole);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("hostRoleData", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->hostRoleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guestRoleData", ::apache::thrift::protocol::T_STRUCT, 40);
  xfer += this->guestRoleData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCQuickMatchLan &a, SCQuickMatchLan &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.isHostRole, b.isHostRole);
  swap(a.hostRoleData, b.hostRoleData);
  swap(a.guestRoleData, b.guestRoleData);
  swap(a.__isset, b.__isset);
}

SCQuickMatchLan::SCQuickMatchLan(const SCQuickMatchLan& other166) {
  result = other166.result;
  isHostRole = other166.isHostRole;
  hostRoleData = other166.hostRoleData;
  guestRoleData = other166.guestRoleData;
  __isset = other166.__isset;
}
SCQuickMatchLan& SCQuickMatchLan::operator=(const SCQuickMatchLan& other167) {
  result = other167.result;
  isHostRole = other167.isHostRole;
  hostRoleData = other167.hostRoleData;
  guestRoleData = other167.guestRoleData;
  __isset = other167.__isset;
  return *this;
}
void SCQuickMatchLan::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCQuickMatchLan(";
  out << "result=" << to_string(result);
  out << ", " << "isHostRole=" << to_string(isHostRole);
  out << ", " << "hostRoleData=" << to_string(hostRoleData);
  out << ", " << "guestRoleData=" << to_string(guestRoleData);
  out << ")";
}


CSQuickMatchCancel::~CSQuickMatchCancel() throw() {
}


uint32_t CSQuickMatchCancel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSQuickMatchCancel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSQuickMatchCancel");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSQuickMatchCancel &a, CSQuickMatchCancel &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSQuickMatchCancel::CSQuickMatchCancel(const CSQuickMatchCancel& other168) {
  (void) other168;
}
CSQuickMatchCancel& CSQuickMatchCancel::operator=(const CSQuickMatchCancel& other169) {
  (void) other169;
  return *this;
}
void CSQuickMatchCancel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSQuickMatchCancel(";
  out << ")";
}


SCQuickMatchCancel::~SCQuickMatchCancel() throw() {
}


void SCQuickMatchCancel::__set_result(const int32_t val) {
  this->result = val;
}

void SCQuickMatchCancel::__set_player(const  ::CytxGame::PlayerData& val) {
  this->player = val;
}

uint32_t SCQuickMatchCancel::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->player.read(iprot);
          this->__isset.player = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCQuickMatchCancel::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCQuickMatchCancel");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("player", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->player.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCQuickMatchCancel &a, SCQuickMatchCancel &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.player, b.player);
  swap(a.__isset, b.__isset);
}

SCQuickMatchCancel::SCQuickMatchCancel(const SCQuickMatchCancel& other170) {
  result = other170.result;
  player = other170.player;
  __isset = other170.__isset;
}
SCQuickMatchCancel& SCQuickMatchCancel::operator=(const SCQuickMatchCancel& other171) {
  result = other171.result;
  player = other171.player;
  __isset = other171.__isset;
  return *this;
}
void SCQuickMatchCancel::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCQuickMatchCancel(";
  out << "result=" << to_string(result);
  out << ", " << "player=" << to_string(player);
  out << ")";
}


CSReplayList::~CSReplayList() throw() {
}


void CSReplayList::__set_userId(const int32_t val) {
  this->userId = val;
}

uint32_t CSReplayList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSReplayList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSReplayList");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSReplayList &a, CSReplayList &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.__isset, b.__isset);
}

CSReplayList::CSReplayList(const CSReplayList& other172) {
  userId = other172.userId;
  __isset = other172.__isset;
}
CSReplayList& CSReplayList::operator=(const CSReplayList& other173) {
  userId = other173.userId;
  __isset = other173.__isset;
  return *this;
}
void CSReplayList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSReplayList(";
  out << "userId=" << to_string(userId);
  out << ")";
}


SCReplayList::~SCReplayList() throw() {
}


void SCReplayList::__set_result(const int32_t val) {
  this->result = val;
}

void SCReplayList::__set_replayList(const std::vector< ::CytxGame::ReplayData> & val) {
  this->replayList = val;
}

uint32_t SCReplayList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->replayList.clear();
            uint32_t _size174;
            ::apache::thrift::protocol::TType _etype177;
            xfer += iprot->readListBegin(_etype177, _size174);
            this->replayList.resize(_size174);
            uint32_t _i178;
            for (_i178 = 0; _i178 < _size174; ++_i178)
            {
              xfer += this->replayList[_i178].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.replayList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCReplayList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCReplayList");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("replayList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->replayList.size()));
    std::vector< ::CytxGame::ReplayData> ::const_iterator _iter179;
    for (_iter179 = this->replayList.begin(); _iter179 != this->replayList.end(); ++_iter179)
    {
      xfer += (*_iter179).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCReplayList &a, SCReplayList &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.replayList, b.replayList);
  swap(a.__isset, b.__isset);
}

SCReplayList::SCReplayList(const SCReplayList& other180) {
  result = other180.result;
  replayList = other180.replayList;
  __isset = other180.__isset;
}
SCReplayList& SCReplayList::operator=(const SCReplayList& other181) {
  result = other181.result;
  replayList = other181.replayList;
  __isset = other181.__isset;
  return *this;
}
void SCReplayList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCReplayList(";
  out << "result=" << to_string(result);
  out << ", " << "replayList=" << to_string(replayList);
  out << ")";
}


CSReplayChoose::~CSReplayChoose() throw() {
}


void CSReplayChoose::__set_userId(const int32_t val) {
  this->userId = val;
}

void CSReplayChoose::__set_timeData(const int64_t val) {
  this->timeData = val;
}

uint32_t CSReplayChoose::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->timeData);
          this->__isset.timeData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSReplayChoose::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSReplayChoose");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeData", ::apache::thrift::protocol::T_I64, 20);
  xfer += oprot->writeI64(this->timeData);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSReplayChoose &a, CSReplayChoose &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.timeData, b.timeData);
  swap(a.__isset, b.__isset);
}

CSReplayChoose::CSReplayChoose(const CSReplayChoose& other182) {
  userId = other182.userId;
  timeData = other182.timeData;
  __isset = other182.__isset;
}
CSReplayChoose& CSReplayChoose::operator=(const CSReplayChoose& other183) {
  userId = other183.userId;
  timeData = other183.timeData;
  __isset = other183.__isset;
  return *this;
}
void CSReplayChoose::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSReplayChoose(";
  out << "userId=" << to_string(userId);
  out << ", " << "timeData=" << to_string(timeData);
  out << ")";
}


SCReplayChoose::~SCReplayChoose() throw() {
}


void SCReplayChoose::__set_result(const int32_t val) {
  this->result = val;
}

void SCReplayChoose::__set_levelData(const  ::CytxGame::LevelData& val) {
  this->levelData = val;
}

void SCReplayChoose::__set_classType(const  ::CytxGame::ClassType::type val) {
  this->classType = val;
}

void SCReplayChoose::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void SCReplayChoose::__set_endFrameIndex(const int32_t val) {
  this->endFrameIndex = val;
}

uint32_t SCReplayChoose::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast184;
          xfer += iprot->readI32(ecast184);
          this->classType = ( ::CytxGame::ClassType::type)ecast184;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->endFrameIndex);
          this->__isset.endFrameIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCReplayChoose::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCReplayChoose");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("endFrameIndex", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->endFrameIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCReplayChoose &a, SCReplayChoose &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.levelData, b.levelData);
  swap(a.classType, b.classType);
  swap(a.levelId, b.levelId);
  swap(a.endFrameIndex, b.endFrameIndex);
  swap(a.__isset, b.__isset);
}

SCReplayChoose::SCReplayChoose(const SCReplayChoose& other185) {
  result = other185.result;
  levelData = other185.levelData;
  classType = other185.classType;
  levelId = other185.levelId;
  endFrameIndex = other185.endFrameIndex;
  __isset = other185.__isset;
}
SCReplayChoose& SCReplayChoose::operator=(const SCReplayChoose& other186) {
  result = other186.result;
  levelData = other186.levelData;
  classType = other186.classType;
  levelId = other186.levelId;
  endFrameIndex = other186.endFrameIndex;
  __isset = other186.__isset;
  return *this;
}
void SCReplayChoose::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCReplayChoose(";
  out << "result=" << to_string(result);
  out << ", " << "levelData=" << to_string(levelData);
  out << ", " << "classType=" << to_string(classType);
  out << ", " << "levelId=" << to_string(levelId);
  out << ", " << "endFrameIndex=" << to_string(endFrameIndex);
  out << ")";
}


CSReplayStart::~CSReplayStart() throw() {
}


uint32_t CSReplayStart::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSReplayStart::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSReplayStart");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSReplayStart &a, CSReplayStart &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSReplayStart::CSReplayStart(const CSReplayStart& other187) {
  (void) other187;
}
CSReplayStart& CSReplayStart::operator=(const CSReplayStart& other188) {
  (void) other188;
  return *this;
}
void CSReplayStart::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSReplayStart(";
  out << ")";
}


SCReplayStart::~SCReplayStart() throw() {
}


void SCReplayStart::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCReplayStart::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCReplayStart::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCReplayStart");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCReplayStart &a, SCReplayStart &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCReplayStart::SCReplayStart(const SCReplayStart& other189) {
  result = other189.result;
  __isset = other189.__isset;
}
SCReplayStart& SCReplayStart::operator=(const SCReplayStart& other190) {
  result = other190.result;
  __isset = other190.__isset;
  return *this;
}
void SCReplayStart::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCReplayStart(";
  out << "result=" << to_string(result);
  out << ")";
}


CSReplayEnd::~CSReplayEnd() throw() {
}


uint32_t CSReplayEnd::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSReplayEnd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSReplayEnd");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSReplayEnd &a, CSReplayEnd &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSReplayEnd::CSReplayEnd(const CSReplayEnd& other191) {
  (void) other191;
}
CSReplayEnd& CSReplayEnd::operator=(const CSReplayEnd& other192) {
  (void) other192;
  return *this;
}
void CSReplayEnd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSReplayEnd(";
  out << ")";
}


SCReplayEnd::~SCReplayEnd() throw() {
}


void SCReplayEnd::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCReplayEnd::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCReplayEnd::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCReplayEnd");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCReplayEnd &a, SCReplayEnd &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCReplayEnd::SCReplayEnd(const SCReplayEnd& other193) {
  result = other193.result;
  __isset = other193.__isset;
}
SCReplayEnd& SCReplayEnd::operator=(const SCReplayEnd& other194) {
  result = other194.result;
  __isset = other194.__isset;
  return *this;
}
void SCReplayEnd::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCReplayEnd(";
  out << "result=" << to_string(result);
  out << ")";
}


CSQuickMatchClassType::~CSQuickMatchClassType() throw() {
}


void CSQuickMatchClassType::__set_classType(const  ::CytxGame::ClassType::type val) {
  this->classType = val;
}

uint32_t CSQuickMatchClassType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast195;
          xfer += iprot->readI32(ecast195);
          this->classType = ( ::CytxGame::ClassType::type)ecast195;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSQuickMatchClassType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSQuickMatchClassType");

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSQuickMatchClassType &a, CSQuickMatchClassType &b) {
  using ::std::swap;
  swap(a.classType, b.classType);
  swap(a.__isset, b.__isset);
}

CSQuickMatchClassType::CSQuickMatchClassType(const CSQuickMatchClassType& other196) {
  classType = other196.classType;
  __isset = other196.__isset;
}
CSQuickMatchClassType& CSQuickMatchClassType::operator=(const CSQuickMatchClassType& other197) {
  classType = other197.classType;
  __isset = other197.__isset;
  return *this;
}
void CSQuickMatchClassType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSQuickMatchClassType(";
  out << "classType=" << to_string(classType);
  out << ")";
}


SCQuickMatchClassType::~SCQuickMatchClassType() throw() {
}


void SCQuickMatchClassType::__set_result(const int32_t val) {
  this->result = val;
}

void SCQuickMatchClassType::__set_classType(const  ::CytxGame::ClassType::type val) {
  this->classType = val;
}

uint32_t SCQuickMatchClassType::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast198;
          xfer += iprot->readI32(ecast198);
          this->classType = ( ::CytxGame::ClassType::type)ecast198;
          this->__isset.classType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCQuickMatchClassType::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCQuickMatchClassType");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("classType", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32((int32_t)this->classType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCQuickMatchClassType &a, SCQuickMatchClassType &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.classType, b.classType);
  swap(a.__isset, b.__isset);
}

SCQuickMatchClassType::SCQuickMatchClassType(const SCQuickMatchClassType& other199) {
  result = other199.result;
  classType = other199.classType;
  __isset = other199.__isset;
}
SCQuickMatchClassType& SCQuickMatchClassType::operator=(const SCQuickMatchClassType& other200) {
  result = other200.result;
  classType = other200.classType;
  __isset = other200.__isset;
  return *this;
}
void SCQuickMatchClassType::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCQuickMatchClassType(";
  out << "result=" << to_string(result);
  out << ", " << "classType=" << to_string(classType);
  out << ")";
}


CSTestProtocol::~CSTestProtocol() throw() {
}


void CSTestProtocol::__set_levelId(const int32_t val) {
  this->levelId = val;
}

void CSTestProtocol::__set_levelData(const  ::CytxGame::LevelData& val) {
  this->levelData = val;
}

uint32_t CSTestProtocol::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->levelId);
          this->__isset.levelId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->levelData.read(iprot);
          this->__isset.levelData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSTestProtocol::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSTestProtocol");

  xfer += oprot->writeFieldBegin("levelId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->levelId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("levelData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->levelData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSTestProtocol &a, CSTestProtocol &b) {
  using ::std::swap;
  swap(a.levelId, b.levelId);
  swap(a.levelData, b.levelData);
  swap(a.__isset, b.__isset);
}

CSTestProtocol::CSTestProtocol(const CSTestProtocol& other201) {
  levelId = other201.levelId;
  levelData = other201.levelData;
  __isset = other201.__isset;
}
CSTestProtocol& CSTestProtocol::operator=(const CSTestProtocol& other202) {
  levelId = other202.levelId;
  levelData = other202.levelData;
  __isset = other202.__isset;
  return *this;
}
void CSTestProtocol::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSTestProtocol(";
  out << "levelId=" << to_string(levelId);
  out << ", " << "levelData=" << to_string(levelData);
  out << ")";
}


SCTestProtocol::~SCTestProtocol() throw() {
}


void SCTestProtocol::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCTestProtocol::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCTestProtocol::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCTestProtocol");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCTestProtocol &a, SCTestProtocol &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCTestProtocol::SCTestProtocol(const SCTestProtocol& other203) {
  result = other203.result;
  __isset = other203.__isset;
}
SCTestProtocol& SCTestProtocol::operator=(const SCTestProtocol& other204) {
  result = other204.result;
  __isset = other204.__isset;
  return *this;
}
void SCTestProtocol::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCTestProtocol(";
  out << "result=" << to_string(result);
  out << ")";
}


CSPing::~CSPing() throw() {
}


uint32_t CSPing::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSPing::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSPing");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSPing &a, CSPing &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSPing::CSPing(const CSPing& other205) {
  (void) other205;
}
CSPing& CSPing::operator=(const CSPing& other206) {
  (void) other206;
  return *this;
}
void CSPing::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSPing(";
  out << ")";
}


SCPing::~SCPing() throw() {
}


void SCPing::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCPing::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCPing::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCPing");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCPing &a, SCPing &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCPing::SCPing(const SCPing& other207) {
  result = other207.result;
  __isset = other207.__isset;
}
SCPing& SCPing::operator=(const SCPing& other208) {
  result = other208.result;
  __isset = other208.__isset;
  return *this;
}
void SCPing::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCPing(";
  out << "result=" << to_string(result);
  out << ")";
}

} // namespace
