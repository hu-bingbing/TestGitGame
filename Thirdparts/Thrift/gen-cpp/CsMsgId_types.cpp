/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "CsMsgId_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kMessageIdValues[] = {
  MessageId::SC_ClientClose,
  MessageId::CS_Login,
  MessageId::SC_Login,
  MessageId::CS_Register,
  MessageId::SC_Register,
  MessageId::CS_TouristLogin,
  MessageId::SC_TouristLogin,
  MessageId::CS_Logout,
  MessageId::SC_Logout,
  MessageId::CS_CreateRoom,
  MessageId::SC_CreateRoom,
  MessageId::CS_JoinRoom,
  MessageId::SC_JoinRoom,
  MessageId::CS_ExitRoom,
  MessageId::SC_ExitRoom,
  MessageId::CS_StartGame,
  MessageId::SC_StartGame,
  MessageId::SC_Frame,
  MessageId::CS_Input,
  MessageId::SC_Input,
  MessageId::CS_ExitGame,
  MessageId::SC_ExitGame,
  MessageId::CS_StartGameConfirm,
  MessageId::SC_StartGameConfirm,
  MessageId::CS_AddFriend,
  MessageId::SC_AddFriend,
  MessageId::CS_DelFriend,
  MessageId::SC_DelFriend,
  MessageId::CS_FindByNickName,
  MessageId::SC_FindByNickName,
  MessageId::CS_GetFriendList,
  MessageId::SC_GetFriendList,
  MessageId::CS_GetFriendRoomList,
  MessageId::SC_GetFriendRoomList,
  MessageId::CS_GetRoomList,
  MessageId::SC_GetRoomList,
  MessageId::SC_RefreshReplayData,
  MessageId::CS_UploadVoice,
  MessageId::SC_UploadVoice,
  MessageId::CS_GetVoice,
  MessageId::SC_GetVoice,
  MessageId::CS_RandomNickname,
  MessageId::SC_RandomNickname,
  MessageId::CS_SetNickname,
  MessageId::SC_SetNickname,
  MessageId::SC_UpdateFriendData,
  MessageId::SC_FriendOnlineInfo,
  MessageId::CS_StartRecord,
  MessageId::SC_StartRecord,
  MessageId::CS_EndRecord,
  MessageId::SC_EndRecord,
  MessageId::CS_EndPlayRecord,
  MessageId::SC_EndPlayRecord,
  MessageId::CS_GetReplay,
  MessageId::SC_GetReplay,
  MessageId::CS_GetReplayInfo,
  MessageId::SC_GetReplayInfo
};
const char* _kMessageIdNames[] = {
  "SC_ClientClose",
  "CS_Login",
  "SC_Login",
  "CS_Register",
  "SC_Register",
  "CS_TouristLogin",
  "SC_TouristLogin",
  "CS_Logout",
  "SC_Logout",
  "CS_CreateRoom",
  "SC_CreateRoom",
  "CS_JoinRoom",
  "SC_JoinRoom",
  "CS_ExitRoom",
  "SC_ExitRoom",
  "CS_StartGame",
  "SC_StartGame",
  "SC_Frame",
  "CS_Input",
  "SC_Input",
  "CS_ExitGame",
  "SC_ExitGame",
  "CS_StartGameConfirm",
  "SC_StartGameConfirm",
  "CS_AddFriend",
  "SC_AddFriend",
  "CS_DelFriend",
  "SC_DelFriend",
  "CS_FindByNickName",
  "SC_FindByNickName",
  "CS_GetFriendList",
  "SC_GetFriendList",
  "CS_GetFriendRoomList",
  "SC_GetFriendRoomList",
  "CS_GetRoomList",
  "SC_GetRoomList",
  "SC_RefreshReplayData",
  "CS_UploadVoice",
  "SC_UploadVoice",
  "CS_GetVoice",
  "SC_GetVoice",
  "CS_RandomNickname",
  "SC_RandomNickname",
  "CS_SetNickname",
  "SC_SetNickname",
  "SC_UpdateFriendData",
  "SC_FriendOnlineInfo",
  "CS_StartRecord",
  "SC_StartRecord",
  "CS_EndRecord",
  "SC_EndRecord",
  "CS_EndPlayRecord",
  "SC_EndPlayRecord",
  "CS_GetReplay",
  "SC_GetReplay",
  "CS_GetReplayInfo",
  "SC_GetReplayInfo"
};
const std::map<int, const char*> _MessageId_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(57, _kMessageIdValues, _kMessageIdNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


CSLogin::~CSLogin() throw() {
}


void CSLogin::__set_userName(const std::string& val) {
  this->userName = val;
}

void CSLogin::__set_password(const std::string& val) {
  this->password = val;
}

uint32_t CSLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSLogin");

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSLogin &a, CSLogin &b) {
  using ::std::swap;
  swap(a.userName, b.userName);
  swap(a.password, b.password);
  swap(a.__isset, b.__isset);
}

CSLogin::CSLogin(const CSLogin& other0) {
  userName = other0.userName;
  password = other0.password;
  __isset = other0.__isset;
}
CSLogin& CSLogin::operator=(const CSLogin& other1) {
  userName = other1.userName;
  password = other1.password;
  __isset = other1.__isset;
  return *this;
}
void CSLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSLogin(";
  out << "userName=" << to_string(userName);
  out << ", " << "password=" << to_string(password);
  out << ")";
}


SCLogin::~SCLogin() throw() {
}


void SCLogin::__set_result(const int32_t val) {
  this->result = val;
}

void SCLogin::__set_userData(const  ::UserData& val) {
  this->userData = val;
}

uint32_t SCLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userData.read(iprot);
          this->__isset.userData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCLogin");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->userData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCLogin &a, SCLogin &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.userData, b.userData);
  swap(a.__isset, b.__isset);
}

SCLogin::SCLogin(const SCLogin& other2) {
  result = other2.result;
  userData = other2.userData;
  __isset = other2.__isset;
}
SCLogin& SCLogin::operator=(const SCLogin& other3) {
  result = other3.result;
  userData = other3.userData;
  __isset = other3.__isset;
  return *this;
}
void SCLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCLogin(";
  out << "result=" << to_string(result);
  out << ", " << "userData=" << to_string(userData);
  out << ")";
}


CSRegister::~CSRegister() throw() {
}


void CSRegister::__set_userName(const std::string& val) {
  this->userName = val;
}

void CSRegister::__set_password(const std::string& val) {
  this->password = val;
}

void CSRegister::__set_email(const std::string& val) {
  this->email = val;
}

uint32_t CSRegister::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->password);
          this->__isset.password = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->email);
          this->__isset.email = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRegister::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRegister");

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("password", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->password);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("email", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->email);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRegister &a, CSRegister &b) {
  using ::std::swap;
  swap(a.userName, b.userName);
  swap(a.password, b.password);
  swap(a.email, b.email);
  swap(a.__isset, b.__isset);
}

CSRegister::CSRegister(const CSRegister& other4) {
  userName = other4.userName;
  password = other4.password;
  email = other4.email;
  __isset = other4.__isset;
}
CSRegister& CSRegister::operator=(const CSRegister& other5) {
  userName = other5.userName;
  password = other5.password;
  email = other5.email;
  __isset = other5.__isset;
  return *this;
}
void CSRegister::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRegister(";
  out << "userName=" << to_string(userName);
  out << ", " << "password=" << to_string(password);
  out << ", " << "email=" << to_string(email);
  out << ")";
}


SCRegister::~SCRegister() throw() {
}


void SCRegister::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCRegister::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRegister::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRegister");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRegister &a, SCRegister &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCRegister::SCRegister(const SCRegister& other6) {
  result = other6.result;
  __isset = other6.__isset;
}
SCRegister& SCRegister::operator=(const SCRegister& other7) {
  result = other7.result;
  __isset = other7.__isset;
  return *this;
}
void SCRegister::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRegister(";
  out << "result=" << to_string(result);
  out << ")";
}


CSTouristLogin::~CSTouristLogin() throw() {
}


void CSTouristLogin::__set_deviceId(const std::string& val) {
  this->deviceId = val;
}

uint32_t CSTouristLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->deviceId);
          this->__isset.deviceId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSTouristLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSTouristLogin");

  xfer += oprot->writeFieldBegin("deviceId", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->deviceId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSTouristLogin &a, CSTouristLogin &b) {
  using ::std::swap;
  swap(a.deviceId, b.deviceId);
  swap(a.__isset, b.__isset);
}

CSTouristLogin::CSTouristLogin(const CSTouristLogin& other8) {
  deviceId = other8.deviceId;
  __isset = other8.__isset;
}
CSTouristLogin& CSTouristLogin::operator=(const CSTouristLogin& other9) {
  deviceId = other9.deviceId;
  __isset = other9.__isset;
  return *this;
}
void CSTouristLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSTouristLogin(";
  out << "deviceId=" << to_string(deviceId);
  out << ")";
}


SCTouristLogin::~SCTouristLogin() throw() {
}


void SCTouristLogin::__set_result(const int32_t val) {
  this->result = val;
}

void SCTouristLogin::__set_userData(const  ::UserData& val) {
  this->userData = val;
}

uint32_t SCTouristLogin::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->userData.read(iprot);
          this->__isset.userData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCTouristLogin::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCTouristLogin");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->userData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCTouristLogin &a, SCTouristLogin &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.userData, b.userData);
  swap(a.__isset, b.__isset);
}

SCTouristLogin::SCTouristLogin(const SCTouristLogin& other10) {
  result = other10.result;
  userData = other10.userData;
  __isset = other10.__isset;
}
SCTouristLogin& SCTouristLogin::operator=(const SCTouristLogin& other11) {
  result = other11.result;
  userData = other11.userData;
  __isset = other11.__isset;
  return *this;
}
void SCTouristLogin::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCTouristLogin(";
  out << "result=" << to_string(result);
  out << ", " << "userData=" << to_string(userData);
  out << ")";
}


CSLogout::~CSLogout() throw() {
}


uint32_t CSLogout::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSLogout::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSLogout");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSLogout &a, CSLogout &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSLogout::CSLogout(const CSLogout& other12) {
  (void) other12;
}
CSLogout& CSLogout::operator=(const CSLogout& other13) {
  (void) other13;
  return *this;
}
void CSLogout::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSLogout(";
  out << ")";
}


SCLogout::~SCLogout() throw() {
}


void SCLogout::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCLogout::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCLogout::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCLogout");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCLogout &a, SCLogout &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCLogout::SCLogout(const SCLogout& other14) {
  result = other14.result;
  __isset = other14.__isset;
}
SCLogout& SCLogout::operator=(const SCLogout& other15) {
  result = other15.result;
  __isset = other15.__isset;
  return *this;
}
void SCLogout::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCLogout(";
  out << "result=" << to_string(result);
  out << ")";
}


CSDisconnect::~CSDisconnect() throw() {
}


uint32_t CSDisconnect::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSDisconnect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSDisconnect");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSDisconnect &a, CSDisconnect &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSDisconnect::CSDisconnect(const CSDisconnect& other16) {
  (void) other16;
}
CSDisconnect& CSDisconnect::operator=(const CSDisconnect& other17) {
  (void) other17;
  return *this;
}
void CSDisconnect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSDisconnect(";
  out << ")";
}


SCDisconnect::~SCDisconnect() throw() {
}


void SCDisconnect::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCDisconnect::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCDisconnect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCDisconnect");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCDisconnect &a, SCDisconnect &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCDisconnect::SCDisconnect(const SCDisconnect& other18) {
  result = other18.result;
  __isset = other18.__isset;
}
SCDisconnect& SCDisconnect::operator=(const SCDisconnect& other19) {
  result = other19.result;
  __isset = other19.__isset;
  return *this;
}
void SCDisconnect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCDisconnect(";
  out << "result=" << to_string(result);
  out << ")";
}


SCRefreshReplayData::~SCRefreshReplayData() throw() {
}


void SCRefreshReplayData::__set_replayData(const  ::ReplayData& val) {
  this->replayData = val;
}

uint32_t SCRefreshReplayData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->replayData.read(iprot);
          this->__isset.replayData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRefreshReplayData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRefreshReplayData");

  xfer += oprot->writeFieldBegin("replayData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->replayData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRefreshReplayData &a, SCRefreshReplayData &b) {
  using ::std::swap;
  swap(a.replayData, b.replayData);
  swap(a.__isset, b.__isset);
}

SCRefreshReplayData::SCRefreshReplayData(const SCRefreshReplayData& other20) {
  replayData = other20.replayData;
  __isset = other20.__isset;
}
SCRefreshReplayData& SCRefreshReplayData::operator=(const SCRefreshReplayData& other21) {
  replayData = other21.replayData;
  __isset = other21.__isset;
  return *this;
}
void SCRefreshReplayData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRefreshReplayData(";
  out << "replayData=" << to_string(replayData);
  out << ")";
}


SCFrame::~SCFrame() throw() {
}


void SCFrame::__set_frameData(const  ::FrameData& val) {
  this->frameData = val;
}

uint32_t SCFrame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frameData.read(iprot);
          this->__isset.frameData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCFrame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCFrame");

  xfer += oprot->writeFieldBegin("frameData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->frameData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCFrame &a, SCFrame &b) {
  using ::std::swap;
  swap(a.frameData, b.frameData);
  swap(a.__isset, b.__isset);
}

SCFrame::SCFrame(const SCFrame& other22) {
  frameData = other22.frameData;
  __isset = other22.__isset;
}
SCFrame& SCFrame::operator=(const SCFrame& other23) {
  frameData = other23.frameData;
  __isset = other23.__isset;
  return *this;
}
void SCFrame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCFrame(";
  out << "frameData=" << to_string(frameData);
  out << ")";
}


CSInput::~CSInput() throw() {
}


void CSInput::__set_commandData(const  ::CommandData& val) {
  this->commandData = val;
}

uint32_t CSInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->commandData.read(iprot);
          this->__isset.commandData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSInput");

  xfer += oprot->writeFieldBegin("commandData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->commandData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSInput &a, CSInput &b) {
  using ::std::swap;
  swap(a.commandData, b.commandData);
  swap(a.__isset, b.__isset);
}

CSInput::CSInput(const CSInput& other24) {
  commandData = other24.commandData;
  __isset = other24.__isset;
}
CSInput& CSInput::operator=(const CSInput& other25) {
  commandData = other25.commandData;
  __isset = other25.__isset;
  return *this;
}
void CSInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSInput(";
  out << "commandData=" << to_string(commandData);
  out << ")";
}


SCInput::~SCInput() throw() {
}


uint32_t SCInput::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCInput::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCInput");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCInput &a, SCInput &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

SCInput::SCInput(const SCInput& other26) {
  (void) other26;
}
SCInput& SCInput::operator=(const SCInput& other27) {
  (void) other27;
  return *this;
}
void SCInput::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCInput(";
  out << ")";
}


CSCreateRoom::~CSCreateRoom() throw() {
}


void CSCreateRoom::__set_roomName(const std::string& val) {
  this->roomName = val;
}

uint32_t CSCreateRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roomName);
          this->__isset.roomName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSCreateRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSCreateRoom");

  xfer += oprot->writeFieldBegin("roomName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->roomName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSCreateRoom &a, CSCreateRoom &b) {
  using ::std::swap;
  swap(a.roomName, b.roomName);
  swap(a.__isset, b.__isset);
}

CSCreateRoom::CSCreateRoom(const CSCreateRoom& other28) {
  roomName = other28.roomName;
  __isset = other28.__isset;
}
CSCreateRoom& CSCreateRoom::operator=(const CSCreateRoom& other29) {
  roomName = other29.roomName;
  __isset = other29.__isset;
  return *this;
}
void CSCreateRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSCreateRoom(";
  out << "roomName=" << to_string(roomName);
  out << ")";
}


SCCreateRoom::~SCCreateRoom() throw() {
}


void SCCreateRoom::__set_result(const int32_t val) {
  this->result = val;
}

void SCCreateRoom::__set_roomId(const int32_t val) {
  this->roomId = val;
}

void SCCreateRoom::__set_roomName(const std::string& val) {
  this->roomName = val;
}

uint32_t SCCreateRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomId);
          this->__isset.roomId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roomName);
          this->__isset.roomName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCCreateRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCCreateRoom");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->roomId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomName", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->roomName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCCreateRoom &a, SCCreateRoom &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.roomId, b.roomId);
  swap(a.roomName, b.roomName);
  swap(a.__isset, b.__isset);
}

SCCreateRoom::SCCreateRoom(const SCCreateRoom& other30) {
  result = other30.result;
  roomId = other30.roomId;
  roomName = other30.roomName;
  __isset = other30.__isset;
}
SCCreateRoom& SCCreateRoom::operator=(const SCCreateRoom& other31) {
  result = other31.result;
  roomId = other31.roomId;
  roomName = other31.roomName;
  __isset = other31.__isset;
  return *this;
}
void SCCreateRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCCreateRoom(";
  out << "result=" << to_string(result);
  out << ", " << "roomId=" << to_string(roomId);
  out << ", " << "roomName=" << to_string(roomName);
  out << ")";
}


CSRoomList::~CSRoomList() throw() {
}


uint32_t CSRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRoomList");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRoomList &a, CSRoomList &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSRoomList::CSRoomList(const CSRoomList& other32) {
  (void) other32;
}
CSRoomList& CSRoomList::operator=(const CSRoomList& other33) {
  (void) other33;
  return *this;
}
void CSRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRoomList(";
  out << ")";
}


SCRoomList::~SCRoomList() throw() {
}


void SCRoomList::__set_result(const int32_t val) {
  this->result = val;
}

void SCRoomList::__set_roomList(const std::vector< ::RoomData> & val) {
  this->roomList = val;
}

uint32_t SCRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->roomList.clear();
            uint32_t _size34;
            ::apache::thrift::protocol::TType _etype37;
            xfer += iprot->readListBegin(_etype37, _size34);
            this->roomList.resize(_size34);
            uint32_t _i38;
            for (_i38 = 0; _i38 < _size34; ++_i38)
            {
              xfer += this->roomList[_i38].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.roomList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRoomList");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->roomList.size()));
    std::vector< ::RoomData> ::const_iterator _iter39;
    for (_iter39 = this->roomList.begin(); _iter39 != this->roomList.end(); ++_iter39)
    {
      xfer += (*_iter39).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRoomList &a, SCRoomList &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.roomList, b.roomList);
  swap(a.__isset, b.__isset);
}

SCRoomList::SCRoomList(const SCRoomList& other40) {
  result = other40.result;
  roomList = other40.roomList;
  __isset = other40.__isset;
}
SCRoomList& SCRoomList::operator=(const SCRoomList& other41) {
  result = other41.result;
  roomList = other41.roomList;
  __isset = other41.__isset;
  return *this;
}
void SCRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRoomList(";
  out << "result=" << to_string(result);
  out << ", " << "roomList=" << to_string(roomList);
  out << ")";
}


CSJoinRoom::~CSJoinRoom() throw() {
}


void CSJoinRoom::__set_roomName(const std::string& val) {
  this->roomName = val;
}

void CSJoinRoom::__set_roomId(const int32_t val) {
  this->roomId = val;
}

uint32_t CSJoinRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->roomName);
          this->__isset.roomName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomId);
          this->__isset.roomId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSJoinRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSJoinRoom");

  xfer += oprot->writeFieldBegin("roomName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->roomName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("roomId", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->roomId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSJoinRoom &a, CSJoinRoom &b) {
  using ::std::swap;
  swap(a.roomName, b.roomName);
  swap(a.roomId, b.roomId);
  swap(a.__isset, b.__isset);
}

CSJoinRoom::CSJoinRoom(const CSJoinRoom& other42) {
  roomName = other42.roomName;
  roomId = other42.roomId;
  __isset = other42.__isset;
}
CSJoinRoom& CSJoinRoom::operator=(const CSJoinRoom& other43) {
  roomName = other43.roomName;
  roomId = other43.roomId;
  __isset = other43.__isset;
  return *this;
}
void CSJoinRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSJoinRoom(";
  out << "roomName=" << to_string(roomName);
  out << ", " << "roomId=" << to_string(roomId);
  out << ")";
}


CSExitRoom::~CSExitRoom() throw() {
}


uint32_t CSExitRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSExitRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSExitRoom");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSExitRoom &a, CSExitRoom &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSExitRoom::CSExitRoom(const CSExitRoom& other44) {
  (void) other44;
}
CSExitRoom& CSExitRoom::operator=(const CSExitRoom& other45) {
  (void) other45;
  return *this;
}
void CSExitRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSExitRoom(";
  out << ")";
}


SCJoinRoom::~SCJoinRoom() throw() {
}


void SCJoinRoom::__set_result(const int32_t val) {
  this->result = val;
}

void SCJoinRoom::__set_playerList(const std::vector< ::PlayerData> & val) {
  this->playerList = val;
}

void SCJoinRoom::__set_joinPlayer(const  ::PlayerData& val) {
  this->joinPlayer = val;
}

uint32_t SCJoinRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->playerList.clear();
            uint32_t _size46;
            ::apache::thrift::protocol::TType _etype49;
            xfer += iprot->readListBegin(_etype49, _size46);
            this->playerList.resize(_size46);
            uint32_t _i50;
            for (_i50 = 0; _i50 < _size46; ++_i50)
            {
              xfer += this->playerList[_i50].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.playerList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->joinPlayer.read(iprot);
          this->__isset.joinPlayer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCJoinRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCJoinRoom");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerList.size()));
    std::vector< ::PlayerData> ::const_iterator _iter51;
    for (_iter51 = this->playerList.begin(); _iter51 != this->playerList.end(); ++_iter51)
    {
      xfer += (*_iter51).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("joinPlayer", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->joinPlayer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCJoinRoom &a, SCJoinRoom &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.playerList, b.playerList);
  swap(a.joinPlayer, b.joinPlayer);
  swap(a.__isset, b.__isset);
}

SCJoinRoom::SCJoinRoom(const SCJoinRoom& other52) {
  result = other52.result;
  playerList = other52.playerList;
  joinPlayer = other52.joinPlayer;
  __isset = other52.__isset;
}
SCJoinRoom& SCJoinRoom::operator=(const SCJoinRoom& other53) {
  result = other53.result;
  playerList = other53.playerList;
  joinPlayer = other53.joinPlayer;
  __isset = other53.__isset;
  return *this;
}
void SCJoinRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCJoinRoom(";
  out << "result=" << to_string(result);
  out << ", " << "playerList=" << to_string(playerList);
  out << ", " << "joinPlayer=" << to_string(joinPlayer);
  out << ")";
}


SCExitRoom::~SCExitRoom() throw() {
}


void SCExitRoom::__set_result(const int32_t val) {
  this->result = val;
}

void SCExitRoom::__set_playerList(const std::vector< ::PlayerData> & val) {
  this->playerList = val;
}

void SCExitRoom::__set_exitPlayer(const  ::PlayerData& val) {
  this->exitPlayer = val;
}

uint32_t SCExitRoom::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->playerList.clear();
            uint32_t _size54;
            ::apache::thrift::protocol::TType _etype57;
            xfer += iprot->readListBegin(_etype57, _size54);
            this->playerList.resize(_size54);
            uint32_t _i58;
            for (_i58 = 0; _i58 < _size54; ++_i58)
            {
              xfer += this->playerList[_i58].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.playerList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->exitPlayer.read(iprot);
          this->__isset.exitPlayer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCExitRoom::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCExitRoom");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerList", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerList.size()));
    std::vector< ::PlayerData> ::const_iterator _iter59;
    for (_iter59 = this->playerList.begin(); _iter59 != this->playerList.end(); ++_iter59)
    {
      xfer += (*_iter59).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exitPlayer", ::apache::thrift::protocol::T_STRUCT, 30);
  xfer += this->exitPlayer.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCExitRoom &a, SCExitRoom &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.playerList, b.playerList);
  swap(a.exitPlayer, b.exitPlayer);
  swap(a.__isset, b.__isset);
}

SCExitRoom::SCExitRoom(const SCExitRoom& other60) {
  result = other60.result;
  playerList = other60.playerList;
  exitPlayer = other60.exitPlayer;
  __isset = other60.__isset;
}
SCExitRoom& SCExitRoom::operator=(const SCExitRoom& other61) {
  result = other61.result;
  playerList = other61.playerList;
  exitPlayer = other61.exitPlayer;
  __isset = other61.__isset;
  return *this;
}
void SCExitRoom::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCExitRoom(";
  out << "result=" << to_string(result);
  out << ", " << "playerList=" << to_string(playerList);
  out << ", " << "exitPlayer=" << to_string(exitPlayer);
  out << ")";
}


CSStartGame::~CSStartGame() throw() {
}


uint32_t CSStartGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSStartGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSStartGame");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSStartGame &a, CSStartGame &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSStartGame::CSStartGame(const CSStartGame& other62) {
  (void) other62;
}
CSStartGame& CSStartGame::operator=(const CSStartGame& other63) {
  (void) other63;
  return *this;
}
void CSStartGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSStartGame(";
  out << ")";
}


SCStartGame::~SCStartGame() throw() {
}


void SCStartGame::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCStartGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCStartGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCStartGame");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCStartGame &a, SCStartGame &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCStartGame::SCStartGame(const SCStartGame& other64) {
  result = other64.result;
  __isset = other64.__isset;
}
SCStartGame& SCStartGame::operator=(const SCStartGame& other65) {
  result = other65.result;
  __isset = other65.__isset;
  return *this;
}
void SCStartGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCStartGame(";
  out << "result=" << to_string(result);
  out << ")";
}


CSRandomNickname::~CSRandomNickname() throw() {
}


uint32_t CSRandomNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSRandomNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSRandomNickname");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSRandomNickname &a, CSRandomNickname &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSRandomNickname::CSRandomNickname(const CSRandomNickname& other66) {
  (void) other66;
}
CSRandomNickname& CSRandomNickname::operator=(const CSRandomNickname& other67) {
  (void) other67;
  return *this;
}
void CSRandomNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSRandomNickname(";
  out << ")";
}


SCRandomNickname::~SCRandomNickname() throw() {
}


void SCRandomNickname::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t SCRandomNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCRandomNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCRandomNickname");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCRandomNickname &a, SCRandomNickname &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

SCRandomNickname::SCRandomNickname(const SCRandomNickname& other68) {
  nickname = other68.nickname;
  __isset = other68.__isset;
}
SCRandomNickname& SCRandomNickname::operator=(const SCRandomNickname& other69) {
  nickname = other69.nickname;
  __isset = other69.__isset;
  return *this;
}
void SCRandomNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCRandomNickname(";
  out << "nickname=" << to_string(nickname);
  out << ")";
}


CSSetNickname::~CSSetNickname() throw() {
}


void CSSetNickname::__set_nickname(const std::string& val) {
  this->nickname = val;
}

void CSSetNickname::__set_iconId(const int32_t val) {
  this->iconId = val;
}

uint32_t CSSetNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->iconId);
          this->__isset.iconId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSSetNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSSetNickname");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("iconId", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->iconId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSSetNickname &a, CSSetNickname &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.iconId, b.iconId);
  swap(a.__isset, b.__isset);
}

CSSetNickname::CSSetNickname(const CSSetNickname& other70) {
  nickname = other70.nickname;
  iconId = other70.iconId;
  __isset = other70.__isset;
}
CSSetNickname& CSSetNickname::operator=(const CSSetNickname& other71) {
  nickname = other71.nickname;
  iconId = other71.iconId;
  __isset = other71.__isset;
  return *this;
}
void CSSetNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSSetNickname(";
  out << "nickname=" << to_string(nickname);
  out << ", " << "iconId=" << to_string(iconId);
  out << ")";
}


SCSetNickname::~SCSetNickname() throw() {
}


void SCSetNickname::__set_result(const int32_t val) {
  this->result = val;
}

void SCSetNickname::__set_playerData(const  ::PlayerData& val) {
  this->playerData = val;
}

uint32_t SCSetNickname::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->playerData.read(iprot);
          this->__isset.playerData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCSetNickname::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCSetNickname");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->playerData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCSetNickname &a, SCSetNickname &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.playerData, b.playerData);
  swap(a.__isset, b.__isset);
}

SCSetNickname::SCSetNickname(const SCSetNickname& other72) {
  result = other72.result;
  playerData = other72.playerData;
  __isset = other72.__isset;
}
SCSetNickname& SCSetNickname::operator=(const SCSetNickname& other73) {
  result = other73.result;
  playerData = other73.playerData;
  __isset = other73.__isset;
  return *this;
}
void SCSetNickname::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCSetNickname(";
  out << "result=" << to_string(result);
  out << ", " << "playerData=" << to_string(playerData);
  out << ")";
}


SCUpdateFriendData::~SCUpdateFriendData() throw() {
}


void SCUpdateFriendData::__set_friendData(const  ::PlayerData& val) {
  this->friendData = val;
}

uint32_t SCUpdateFriendData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->friendData.read(iprot);
          this->__isset.friendData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCUpdateFriendData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCUpdateFriendData");

  xfer += oprot->writeFieldBegin("friendData", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->friendData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCUpdateFriendData &a, SCUpdateFriendData &b) {
  using ::std::swap;
  swap(a.friendData, b.friendData);
  swap(a.__isset, b.__isset);
}

SCUpdateFriendData::SCUpdateFriendData(const SCUpdateFriendData& other74) {
  friendData = other74.friendData;
  __isset = other74.__isset;
}
SCUpdateFriendData& SCUpdateFriendData::operator=(const SCUpdateFriendData& other75) {
  friendData = other75.friendData;
  __isset = other75.__isset;
  return *this;
}
void SCUpdateFriendData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCUpdateFriendData(";
  out << "friendData=" << to_string(friendData);
  out << ")";
}


CSReconnect::~CSReconnect() throw() {
}


void CSReconnect::__set_keyReconnect(const int32_t val) {
  this->keyReconnect = val;
}

uint32_t CSReconnect::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->keyReconnect);
          this->__isset.keyReconnect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSReconnect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSReconnect");

  xfer += oprot->writeFieldBegin("keyReconnect", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->keyReconnect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSReconnect &a, CSReconnect &b) {
  using ::std::swap;
  swap(a.keyReconnect, b.keyReconnect);
  swap(a.__isset, b.__isset);
}

CSReconnect::CSReconnect(const CSReconnect& other76) {
  keyReconnect = other76.keyReconnect;
  __isset = other76.__isset;
}
CSReconnect& CSReconnect::operator=(const CSReconnect& other77) {
  keyReconnect = other77.keyReconnect;
  __isset = other77.__isset;
  return *this;
}
void CSReconnect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSReconnect(";
  out << "keyReconnect=" << to_string(keyReconnect);
  out << ")";
}


SCReconnect::~SCReconnect() throw() {
}


void SCReconnect::__set_keyReconnect(const int32_t val) {
  this->keyReconnect = val;
}

uint32_t SCReconnect::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->keyReconnect);
          this->__isset.keyReconnect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCReconnect::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCReconnect");

  xfer += oprot->writeFieldBegin("keyReconnect", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->keyReconnect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCReconnect &a, SCReconnect &b) {
  using ::std::swap;
  swap(a.keyReconnect, b.keyReconnect);
  swap(a.__isset, b.__isset);
}

SCReconnect::SCReconnect(const SCReconnect& other78) {
  keyReconnect = other78.keyReconnect;
  __isset = other78.__isset;
}
SCReconnect& SCReconnect::operator=(const SCReconnect& other79) {
  keyReconnect = other79.keyReconnect;
  __isset = other79.__isset;
  return *this;
}
void SCReconnect::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCReconnect(";
  out << "keyReconnect=" << to_string(keyReconnect);
  out << ")";
}


CSAddFriend::~CSAddFriend() throw() {
}


void CSAddFriend::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t CSAddFriend::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSAddFriend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSAddFriend");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSAddFriend &a, CSAddFriend &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

CSAddFriend::CSAddFriend(const CSAddFriend& other80) {
  nickname = other80.nickname;
  __isset = other80.__isset;
}
CSAddFriend& CSAddFriend::operator=(const CSAddFriend& other81) {
  nickname = other81.nickname;
  __isset = other81.__isset;
  return *this;
}
void CSAddFriend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSAddFriend(";
  out << "nickname=" << to_string(nickname);
  out << ")";
}


SCAddFriend::~SCAddFriend() throw() {
}


void SCAddFriend::__set_result(const int32_t val) {
  this->result = val;
}

void SCAddFriend::__set_friendInfo(const  ::PlayerData& val) {
  this->friendInfo = val;
}

uint32_t SCAddFriend::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->friendInfo.read(iprot);
          this->__isset.friendInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCAddFriend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCAddFriend");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("friendInfo", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->friendInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCAddFriend &a, SCAddFriend &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.friendInfo, b.friendInfo);
  swap(a.__isset, b.__isset);
}

SCAddFriend::SCAddFriend(const SCAddFriend& other82) {
  result = other82.result;
  friendInfo = other82.friendInfo;
  __isset = other82.__isset;
}
SCAddFriend& SCAddFriend::operator=(const SCAddFriend& other83) {
  result = other83.result;
  friendInfo = other83.friendInfo;
  __isset = other83.__isset;
  return *this;
}
void SCAddFriend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCAddFriend(";
  out << "result=" << to_string(result);
  out << ", " << "friendInfo=" << to_string(friendInfo);
  out << ")";
}


CSDelFriend::~CSDelFriend() throw() {
}


void CSDelFriend::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t CSDelFriend::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSDelFriend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSDelFriend");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSDelFriend &a, CSDelFriend &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

CSDelFriend::CSDelFriend(const CSDelFriend& other84) {
  nickname = other84.nickname;
  __isset = other84.__isset;
}
CSDelFriend& CSDelFriend::operator=(const CSDelFriend& other85) {
  nickname = other85.nickname;
  __isset = other85.__isset;
  return *this;
}
void CSDelFriend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSDelFriend(";
  out << "nickname=" << to_string(nickname);
  out << ")";
}


SCDelFriend::~SCDelFriend() throw() {
}


void SCDelFriend::__set_result(const int32_t val) {
  this->result = val;
}

void SCDelFriend::__set_friendInfo(const  ::PlayerData& val) {
  this->friendInfo = val;
}

uint32_t SCDelFriend::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->friendInfo.read(iprot);
          this->__isset.friendInfo = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCDelFriend::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCDelFriend");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("friendInfo", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->friendInfo.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCDelFriend &a, SCDelFriend &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.friendInfo, b.friendInfo);
  swap(a.__isset, b.__isset);
}

SCDelFriend::SCDelFriend(const SCDelFriend& other86) {
  result = other86.result;
  friendInfo = other86.friendInfo;
  __isset = other86.__isset;
}
SCDelFriend& SCDelFriend::operator=(const SCDelFriend& other87) {
  result = other87.result;
  friendInfo = other87.friendInfo;
  __isset = other87.__isset;
  return *this;
}
void SCDelFriend::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCDelFriend(";
  out << "result=" << to_string(result);
  out << ", " << "friendInfo=" << to_string(friendInfo);
  out << ")";
}


CSFindByNickName::~CSFindByNickName() throw() {
}


void CSFindByNickName::__set_nickname(const std::string& val) {
  this->nickname = val;
}

uint32_t CSFindByNickName::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nickname);
          this->__isset.nickname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSFindByNickName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSFindByNickName");

  xfer += oprot->writeFieldBegin("nickname", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->nickname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSFindByNickName &a, CSFindByNickName &b) {
  using ::std::swap;
  swap(a.nickname, b.nickname);
  swap(a.__isset, b.__isset);
}

CSFindByNickName::CSFindByNickName(const CSFindByNickName& other88) {
  nickname = other88.nickname;
  __isset = other88.__isset;
}
CSFindByNickName& CSFindByNickName::operator=(const CSFindByNickName& other89) {
  nickname = other89.nickname;
  __isset = other89.__isset;
  return *this;
}
void CSFindByNickName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSFindByNickName(";
  out << "nickname=" << to_string(nickname);
  out << ")";
}


SCFindByNickName::~SCFindByNickName() throw() {
}


void SCFindByNickName::__set_friendList(const std::vector< ::PlayerData> & val) {
  this->friendList = val;
}

uint32_t SCFindByNickName::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->friendList.clear();
            uint32_t _size90;
            ::apache::thrift::protocol::TType _etype93;
            xfer += iprot->readListBegin(_etype93, _size90);
            this->friendList.resize(_size90);
            uint32_t _i94;
            for (_i94 = 0; _i94 < _size90; ++_i94)
            {
              xfer += this->friendList[_i94].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.friendList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCFindByNickName::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCFindByNickName");

  xfer += oprot->writeFieldBegin("friendList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->friendList.size()));
    std::vector< ::PlayerData> ::const_iterator _iter95;
    for (_iter95 = this->friendList.begin(); _iter95 != this->friendList.end(); ++_iter95)
    {
      xfer += (*_iter95).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCFindByNickName &a, SCFindByNickName &b) {
  using ::std::swap;
  swap(a.friendList, b.friendList);
  swap(a.__isset, b.__isset);
}

SCFindByNickName::SCFindByNickName(const SCFindByNickName& other96) {
  friendList = other96.friendList;
  __isset = other96.__isset;
}
SCFindByNickName& SCFindByNickName::operator=(const SCFindByNickName& other97) {
  friendList = other97.friendList;
  __isset = other97.__isset;
  return *this;
}
void SCFindByNickName::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCFindByNickName(";
  out << "friendList=" << to_string(friendList);
  out << ")";
}


CSGetFriendList::~CSGetFriendList() throw() {
}


void CSGetFriendList::__set_userName(const std::string& val) {
  this->userName = val;
}

uint32_t CSGetFriendList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->userName);
          this->__isset.userName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSGetFriendList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSGetFriendList");

  xfer += oprot->writeFieldBegin("userName", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->userName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSGetFriendList &a, CSGetFriendList &b) {
  using ::std::swap;
  swap(a.userName, b.userName);
  swap(a.__isset, b.__isset);
}

CSGetFriendList::CSGetFriendList(const CSGetFriendList& other98) {
  userName = other98.userName;
  __isset = other98.__isset;
}
CSGetFriendList& CSGetFriendList::operator=(const CSGetFriendList& other99) {
  userName = other99.userName;
  __isset = other99.__isset;
  return *this;
}
void CSGetFriendList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSGetFriendList(";
  out << "userName=" << to_string(userName);
  out << ")";
}


SCGetFriendList::~SCGetFriendList() throw() {
}


void SCGetFriendList::__set_friendList(const std::vector< ::PlayerData> & val) {
  this->friendList = val;
}

uint32_t SCGetFriendList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->friendList.clear();
            uint32_t _size100;
            ::apache::thrift::protocol::TType _etype103;
            xfer += iprot->readListBegin(_etype103, _size100);
            this->friendList.resize(_size100);
            uint32_t _i104;
            for (_i104 = 0; _i104 < _size100; ++_i104)
            {
              xfer += this->friendList[_i104].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.friendList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCGetFriendList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCGetFriendList");

  xfer += oprot->writeFieldBegin("friendList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->friendList.size()));
    std::vector< ::PlayerData> ::const_iterator _iter105;
    for (_iter105 = this->friendList.begin(); _iter105 != this->friendList.end(); ++_iter105)
    {
      xfer += (*_iter105).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCGetFriendList &a, SCGetFriendList &b) {
  using ::std::swap;
  swap(a.friendList, b.friendList);
  swap(a.__isset, b.__isset);
}

SCGetFriendList::SCGetFriendList(const SCGetFriendList& other106) {
  friendList = other106.friendList;
  __isset = other106.__isset;
}
SCGetFriendList& SCGetFriendList::operator=(const SCGetFriendList& other107) {
  friendList = other107.friendList;
  __isset = other107.__isset;
  return *this;
}
void SCGetFriendList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCGetFriendList(";
  out << "friendList=" << to_string(friendList);
  out << ")";
}


CSStartGameConfirm::~CSStartGameConfirm() throw() {
}


uint32_t CSStartGameConfirm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSStartGameConfirm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSStartGameConfirm");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSStartGameConfirm &a, CSStartGameConfirm &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSStartGameConfirm::CSStartGameConfirm(const CSStartGameConfirm& other108) {
  (void) other108;
}
CSStartGameConfirm& CSStartGameConfirm::operator=(const CSStartGameConfirm& other109) {
  (void) other109;
  return *this;
}
void CSStartGameConfirm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSStartGameConfirm(";
  out << ")";
}


SCStartGameConfirm::~SCStartGameConfirm() throw() {
}


uint32_t SCStartGameConfirm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCStartGameConfirm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCStartGameConfirm");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCStartGameConfirm &a, SCStartGameConfirm &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

SCStartGameConfirm::SCStartGameConfirm(const SCStartGameConfirm& other110) {
  (void) other110;
}
SCStartGameConfirm& SCStartGameConfirm::operator=(const SCStartGameConfirm& other111) {
  (void) other111;
  return *this;
}
void SCStartGameConfirm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCStartGameConfirm(";
  out << ")";
}


CSGetReplayInfo::~CSGetReplayInfo() throw() {
}


void CSGetReplayInfo::__set_roomId(const int32_t val) {
  this->roomId = val;
}

uint32_t CSGetReplayInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomId);
          this->__isset.roomId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSGetReplayInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSGetReplayInfo");

  xfer += oprot->writeFieldBegin("roomId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->roomId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSGetReplayInfo &a, CSGetReplayInfo &b) {
  using ::std::swap;
  swap(a.roomId, b.roomId);
  swap(a.__isset, b.__isset);
}

CSGetReplayInfo::CSGetReplayInfo(const CSGetReplayInfo& other112) {
  roomId = other112.roomId;
  __isset = other112.__isset;
}
CSGetReplayInfo& CSGetReplayInfo::operator=(const CSGetReplayInfo& other113) {
  roomId = other113.roomId;
  __isset = other113.__isset;
  return *this;
}
void CSGetReplayInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSGetReplayInfo(";
  out << "roomId=" << to_string(roomId);
  out << ")";
}


SCGetReplayInfo::~SCGetReplayInfo() throw() {
}


void SCGetReplayInfo::__set_lastFrameIndex(const int32_t val) {
  this->lastFrameIndex = val;
}

void SCGetReplayInfo::__set_influenceFrameCount(const int32_t val) {
  this->influenceFrameCount = val;
}

void SCGetReplayInfo::__set_playerList(const std::vector< ::PlayerData> & val) {
  this->playerList = val;
}

void SCGetReplayInfo::__set_playerExitFrameList(const std::vector<int32_t> & val) {
  this->playerExitFrameList = val;
}

uint32_t SCGetReplayInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->lastFrameIndex);
          this->__isset.lastFrameIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->influenceFrameCount);
          this->__isset.influenceFrameCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->playerList.clear();
            uint32_t _size114;
            ::apache::thrift::protocol::TType _etype117;
            xfer += iprot->readListBegin(_etype117, _size114);
            this->playerList.resize(_size114);
            uint32_t _i118;
            for (_i118 = 0; _i118 < _size114; ++_i118)
            {
              xfer += this->playerList[_i118].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.playerList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->playerExitFrameList.clear();
            uint32_t _size119;
            ::apache::thrift::protocol::TType _etype122;
            xfer += iprot->readListBegin(_etype122, _size119);
            this->playerExitFrameList.resize(_size119);
            uint32_t _i123;
            for (_i123 = 0; _i123 < _size119; ++_i123)
            {
              xfer += iprot->readI32(this->playerExitFrameList[_i123]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.playerExitFrameList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCGetReplayInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCGetReplayInfo");

  xfer += oprot->writeFieldBegin("lastFrameIndex", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->lastFrameIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("influenceFrameCount", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->influenceFrameCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerList", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->playerList.size()));
    std::vector< ::PlayerData> ::const_iterator _iter124;
    for (_iter124 = this->playerList.begin(); _iter124 != this->playerList.end(); ++_iter124)
    {
      xfer += (*_iter124).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerExitFrameList", ::apache::thrift::protocol::T_LIST, 40);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->playerExitFrameList.size()));
    std::vector<int32_t> ::const_iterator _iter125;
    for (_iter125 = this->playerExitFrameList.begin(); _iter125 != this->playerExitFrameList.end(); ++_iter125)
    {
      xfer += oprot->writeI32((*_iter125));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCGetReplayInfo &a, SCGetReplayInfo &b) {
  using ::std::swap;
  swap(a.lastFrameIndex, b.lastFrameIndex);
  swap(a.influenceFrameCount, b.influenceFrameCount);
  swap(a.playerList, b.playerList);
  swap(a.playerExitFrameList, b.playerExitFrameList);
  swap(a.__isset, b.__isset);
}

SCGetReplayInfo::SCGetReplayInfo(const SCGetReplayInfo& other126) {
  lastFrameIndex = other126.lastFrameIndex;
  influenceFrameCount = other126.influenceFrameCount;
  playerList = other126.playerList;
  playerExitFrameList = other126.playerExitFrameList;
  __isset = other126.__isset;
}
SCGetReplayInfo& SCGetReplayInfo::operator=(const SCGetReplayInfo& other127) {
  lastFrameIndex = other127.lastFrameIndex;
  influenceFrameCount = other127.influenceFrameCount;
  playerList = other127.playerList;
  playerExitFrameList = other127.playerExitFrameList;
  __isset = other127.__isset;
  return *this;
}
void SCGetReplayInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCGetReplayInfo(";
  out << "lastFrameIndex=" << to_string(lastFrameIndex);
  out << ", " << "influenceFrameCount=" << to_string(influenceFrameCount);
  out << ", " << "playerList=" << to_string(playerList);
  out << ", " << "playerExitFrameList=" << to_string(playerExitFrameList);
  out << ")";
}


CSGetReplay::~CSGetReplay() throw() {
}


void CSGetReplay::__set_roomId(const int32_t val) {
  this->roomId = val;
}

void CSGetReplay::__set_influenceStartIndex(const int32_t val) {
  this->influenceStartIndex = val;
}

void CSGetReplay::__set_influenceCount(const int32_t val) {
  this->influenceCount = val;
}

uint32_t CSGetReplay::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomId);
          this->__isset.roomId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->influenceStartIndex);
          this->__isset.influenceStartIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->influenceCount);
          this->__isset.influenceCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSGetReplay::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSGetReplay");

  xfer += oprot->writeFieldBegin("roomId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->roomId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("influenceStartIndex", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->influenceStartIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("influenceCount", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->influenceCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSGetReplay &a, CSGetReplay &b) {
  using ::std::swap;
  swap(a.roomId, b.roomId);
  swap(a.influenceStartIndex, b.influenceStartIndex);
  swap(a.influenceCount, b.influenceCount);
  swap(a.__isset, b.__isset);
}

CSGetReplay::CSGetReplay(const CSGetReplay& other128) {
  roomId = other128.roomId;
  influenceStartIndex = other128.influenceStartIndex;
  influenceCount = other128.influenceCount;
  __isset = other128.__isset;
}
CSGetReplay& CSGetReplay::operator=(const CSGetReplay& other129) {
  roomId = other129.roomId;
  influenceStartIndex = other129.influenceStartIndex;
  influenceCount = other129.influenceCount;
  __isset = other129.__isset;
  return *this;
}
void CSGetReplay::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSGetReplay(";
  out << "roomId=" << to_string(roomId);
  out << ", " << "influenceStartIndex=" << to_string(influenceStartIndex);
  out << ", " << "influenceCount=" << to_string(influenceCount);
  out << ")";
}


SCGetReplay::~SCGetReplay() throw() {
}


void SCGetReplay::__set_frameList(const std::vector< ::FrameData> & val) {
  this->frameList = val;
}

uint32_t SCGetReplay::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->frameList.clear();
            uint32_t _size130;
            ::apache::thrift::protocol::TType _etype133;
            xfer += iprot->readListBegin(_etype133, _size130);
            this->frameList.resize(_size130);
            uint32_t _i134;
            for (_i134 = 0; _i134 < _size130; ++_i134)
            {
              xfer += this->frameList[_i134].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.frameList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCGetReplay::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCGetReplay");

  xfer += oprot->writeFieldBegin("frameList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->frameList.size()));
    std::vector< ::FrameData> ::const_iterator _iter135;
    for (_iter135 = this->frameList.begin(); _iter135 != this->frameList.end(); ++_iter135)
    {
      xfer += (*_iter135).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCGetReplay &a, SCGetReplay &b) {
  using ::std::swap;
  swap(a.frameList, b.frameList);
  swap(a.__isset, b.__isset);
}

SCGetReplay::SCGetReplay(const SCGetReplay& other136) {
  frameList = other136.frameList;
  __isset = other136.__isset;
}
SCGetReplay& SCGetReplay::operator=(const SCGetReplay& other137) {
  frameList = other137.frameList;
  __isset = other137.__isset;
  return *this;
}
void SCGetReplay::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCGetReplay(";
  out << "frameList=" << to_string(frameList);
  out << ")";
}


CSGetFriendRoomList::~CSGetFriendRoomList() throw() {
}


void CSGetFriendRoomList::__set_startIndex(const int32_t val) {
  this->startIndex = val;
}

void CSGetFriendRoomList::__set_count(const int32_t val) {
  this->count = val;
}

uint32_t CSGetFriendRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startIndex);
          this->__isset.startIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSGetFriendRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSGetFriendRoomList");

  xfer += oprot->writeFieldBegin("startIndex", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->startIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSGetFriendRoomList &a, CSGetFriendRoomList &b) {
  using ::std::swap;
  swap(a.startIndex, b.startIndex);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

CSGetFriendRoomList::CSGetFriendRoomList(const CSGetFriendRoomList& other138) {
  startIndex = other138.startIndex;
  count = other138.count;
  __isset = other138.__isset;
}
CSGetFriendRoomList& CSGetFriendRoomList::operator=(const CSGetFriendRoomList& other139) {
  startIndex = other139.startIndex;
  count = other139.count;
  __isset = other139.__isset;
  return *this;
}
void CSGetFriendRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSGetFriendRoomList(";
  out << "startIndex=" << to_string(startIndex);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


SCGetFriendRoomList::~SCGetFriendRoomList() throw() {
}


void SCGetFriendRoomList::__set_roomList(const std::vector< ::RoomInfo> & val) {
  this->roomList = val;
}

void SCGetFriendRoomList::__set_totalCount(const int32_t val) {
  this->totalCount = val;
}

uint32_t SCGetFriendRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->roomList.clear();
            uint32_t _size140;
            ::apache::thrift::protocol::TType _etype143;
            xfer += iprot->readListBegin(_etype143, _size140);
            this->roomList.resize(_size140);
            uint32_t _i144;
            for (_i144 = 0; _i144 < _size140; ++_i144)
            {
              xfer += this->roomList[_i144].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.roomList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalCount);
          this->__isset.totalCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCGetFriendRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCGetFriendRoomList");

  xfer += oprot->writeFieldBegin("roomList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->roomList.size()));
    std::vector< ::RoomInfo> ::const_iterator _iter145;
    for (_iter145 = this->roomList.begin(); _iter145 != this->roomList.end(); ++_iter145)
    {
      xfer += (*_iter145).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalCount", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->totalCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCGetFriendRoomList &a, SCGetFriendRoomList &b) {
  using ::std::swap;
  swap(a.roomList, b.roomList);
  swap(a.totalCount, b.totalCount);
  swap(a.__isset, b.__isset);
}

SCGetFriendRoomList::SCGetFriendRoomList(const SCGetFriendRoomList& other146) {
  roomList = other146.roomList;
  totalCount = other146.totalCount;
  __isset = other146.__isset;
}
SCGetFriendRoomList& SCGetFriendRoomList::operator=(const SCGetFriendRoomList& other147) {
  roomList = other147.roomList;
  totalCount = other147.totalCount;
  __isset = other147.__isset;
  return *this;
}
void SCGetFriendRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCGetFriendRoomList(";
  out << "roomList=" << to_string(roomList);
  out << ", " << "totalCount=" << to_string(totalCount);
  out << ")";
}


CSGetRoomList::~CSGetRoomList() throw() {
}


void CSGetRoomList::__set_startIndex(const int32_t val) {
  this->startIndex = val;
}

void CSGetRoomList::__set_count(const int32_t val) {
  this->count = val;
}

uint32_t CSGetRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->startIndex);
          this->__isset.startIndex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->count);
          this->__isset.count = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSGetRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSGetRoomList");

  xfer += oprot->writeFieldBegin("startIndex", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->startIndex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("count", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->count);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSGetRoomList &a, CSGetRoomList &b) {
  using ::std::swap;
  swap(a.startIndex, b.startIndex);
  swap(a.count, b.count);
  swap(a.__isset, b.__isset);
}

CSGetRoomList::CSGetRoomList(const CSGetRoomList& other148) {
  startIndex = other148.startIndex;
  count = other148.count;
  __isset = other148.__isset;
}
CSGetRoomList& CSGetRoomList::operator=(const CSGetRoomList& other149) {
  startIndex = other149.startIndex;
  count = other149.count;
  __isset = other149.__isset;
  return *this;
}
void CSGetRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSGetRoomList(";
  out << "startIndex=" << to_string(startIndex);
  out << ", " << "count=" << to_string(count);
  out << ")";
}


SCGetRoomList::~SCGetRoomList() throw() {
}


void SCGetRoomList::__set_roomList(const std::vector< ::RoomInfo> & val) {
  this->roomList = val;
}

void SCGetRoomList::__set_totalCount(const int32_t val) {
  this->totalCount = val;
}

uint32_t SCGetRoomList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->roomList.clear();
            uint32_t _size150;
            ::apache::thrift::protocol::TType _etype153;
            xfer += iprot->readListBegin(_etype153, _size150);
            this->roomList.resize(_size150);
            uint32_t _i154;
            for (_i154 = 0; _i154 < _size150; ++_i154)
            {
              xfer += this->roomList[_i154].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.roomList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalCount);
          this->__isset.totalCount = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCGetRoomList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCGetRoomList");

  xfer += oprot->writeFieldBegin("roomList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->roomList.size()));
    std::vector< ::RoomInfo> ::const_iterator _iter155;
    for (_iter155 = this->roomList.begin(); _iter155 != this->roomList.end(); ++_iter155)
    {
      xfer += (*_iter155).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalCount", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->totalCount);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCGetRoomList &a, SCGetRoomList &b) {
  using ::std::swap;
  swap(a.roomList, b.roomList);
  swap(a.totalCount, b.totalCount);
  swap(a.__isset, b.__isset);
}

SCGetRoomList::SCGetRoomList(const SCGetRoomList& other156) {
  roomList = other156.roomList;
  totalCount = other156.totalCount;
  __isset = other156.__isset;
}
SCGetRoomList& SCGetRoomList::operator=(const SCGetRoomList& other157) {
  roomList = other157.roomList;
  totalCount = other157.totalCount;
  __isset = other157.__isset;
  return *this;
}
void SCGetRoomList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCGetRoomList(";
  out << "roomList=" << to_string(roomList);
  out << ", " << "totalCount=" << to_string(totalCount);
  out << ")";
}


CSExitGame::~CSExitGame() throw() {
}


uint32_t CSExitGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSExitGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSExitGame");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSExitGame &a, CSExitGame &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSExitGame::CSExitGame(const CSExitGame& other158) {
  (void) other158;
}
CSExitGame& CSExitGame::operator=(const CSExitGame& other159) {
  (void) other159;
  return *this;
}
void CSExitGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSExitGame(";
  out << ")";
}


SCExitGame::~SCExitGame() throw() {
}


void SCExitGame::__set_userId(const int64_t val) {
  this->userId = val;
}

uint32_t SCExitGame::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCExitGame::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCExitGame");

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I64, 10);
  xfer += oprot->writeI64(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCExitGame &a, SCExitGame &b) {
  using ::std::swap;
  swap(a.userId, b.userId);
  swap(a.__isset, b.__isset);
}

SCExitGame::SCExitGame(const SCExitGame& other160) {
  userId = other160.userId;
  __isset = other160.__isset;
}
SCExitGame& SCExitGame::operator=(const SCExitGame& other161) {
  userId = other161.userId;
  __isset = other161.__isset;
  return *this;
}
void SCExitGame::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCExitGame(";
  out << "userId=" << to_string(userId);
  out << ")";
}


CSUploadVoice::~CSUploadVoice() throw() {
}


void CSUploadVoice::__set_index(const int32_t val) {
  this->index = val;
}

void CSUploadVoice::__set_url(const std::string& val) {
  this->url = val;
}

uint32_t CSUploadVoice::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSUploadVoice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSUploadVoice");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSUploadVoice &a, CSUploadVoice &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.url, b.url);
  swap(a.__isset, b.__isset);
}

CSUploadVoice::CSUploadVoice(const CSUploadVoice& other162) {
  index = other162.index;
  url = other162.url;
  __isset = other162.__isset;
}
CSUploadVoice& CSUploadVoice::operator=(const CSUploadVoice& other163) {
  index = other163.index;
  url = other163.url;
  __isset = other163.__isset;
  return *this;
}
void CSUploadVoice::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSUploadVoice(";
  out << "index=" << to_string(index);
  out << ", " << "url=" << to_string(url);
  out << ")";
}


SCUploadVoice::~SCUploadVoice() throw() {
}


void SCUploadVoice::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCUploadVoice::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCUploadVoice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCUploadVoice");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCUploadVoice &a, SCUploadVoice &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCUploadVoice::SCUploadVoice(const SCUploadVoice& other164) {
  result = other164.result;
  __isset = other164.__isset;
}
SCUploadVoice& SCUploadVoice::operator=(const SCUploadVoice& other165) {
  result = other165.result;
  __isset = other165.__isset;
  return *this;
}
void SCUploadVoice::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCUploadVoice(";
  out << "result=" << to_string(result);
  out << ")";
}


CSGetVoice::~CSGetVoice() throw() {
}


void CSGetVoice::__set_roomId(const int32_t val) {
  this->roomId = val;
}

void CSGetVoice::__set_index(const int32_t val) {
  this->index = val;
}

uint32_t CSGetVoice::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->roomId);
          this->__isset.roomId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSGetVoice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSGetVoice");

  xfer += oprot->writeFieldBegin("roomId", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->roomId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSGetVoice &a, CSGetVoice &b) {
  using ::std::swap;
  swap(a.roomId, b.roomId);
  swap(a.index, b.index);
  swap(a.__isset, b.__isset);
}

CSGetVoice::CSGetVoice(const CSGetVoice& other166) {
  roomId = other166.roomId;
  index = other166.index;
  __isset = other166.__isset;
}
CSGetVoice& CSGetVoice::operator=(const CSGetVoice& other167) {
  roomId = other167.roomId;
  index = other167.index;
  __isset = other167.__isset;
  return *this;
}
void CSGetVoice::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSGetVoice(";
  out << "roomId=" << to_string(roomId);
  out << ", " << "index=" << to_string(index);
  out << ")";
}


SCGetVoice::~SCGetVoice() throw() {
}


void SCGetVoice::__set_url(const std::string& val) {
  this->url = val;
}

uint32_t SCGetVoice::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCGetVoice::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCGetVoice");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCGetVoice &a, SCGetVoice &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.__isset, b.__isset);
}

SCGetVoice::SCGetVoice(const SCGetVoice& other168) {
  url = other168.url;
  __isset = other168.__isset;
}
SCGetVoice& SCGetVoice::operator=(const SCGetVoice& other169) {
  url = other169.url;
  __isset = other169.__isset;
  return *this;
}
void SCGetVoice::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCGetVoice(";
  out << "url=" << to_string(url);
  out << ")";
}


SClientClose::~SClientClose() throw() {
}


uint32_t SClientClose::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SClientClose::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SClientClose");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SClientClose &a, SClientClose &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

SClientClose::SClientClose(const SClientClose& other170) {
  (void) other170;
}
SClientClose& SClientClose::operator=(const SClientClose& other171) {
  (void) other171;
  return *this;
}
void SClientClose::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SClientClose(";
  out << ")";
}


SCFriendOnlineInfo::~SCFriendOnlineInfo() throw() {
}


void SCFriendOnlineInfo::__set_onlineStatus(const bool val) {
  this->onlineStatus = val;
}

void SCFriendOnlineInfo::__set_playerData(const  ::PlayerData& val) {
  this->playerData = val;
}

uint32_t SCFriendOnlineInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->onlineStatus);
          this->__isset.onlineStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->playerData.read(iprot);
          this->__isset.playerData = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCFriendOnlineInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCFriendOnlineInfo");

  xfer += oprot->writeFieldBegin("onlineStatus", ::apache::thrift::protocol::T_BOOL, 10);
  xfer += oprot->writeBool(this->onlineStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("playerData", ::apache::thrift::protocol::T_STRUCT, 20);
  xfer += this->playerData.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCFriendOnlineInfo &a, SCFriendOnlineInfo &b) {
  using ::std::swap;
  swap(a.onlineStatus, b.onlineStatus);
  swap(a.playerData, b.playerData);
  swap(a.__isset, b.__isset);
}

SCFriendOnlineInfo::SCFriendOnlineInfo(const SCFriendOnlineInfo& other172) {
  onlineStatus = other172.onlineStatus;
  playerData = other172.playerData;
  __isset = other172.__isset;
}
SCFriendOnlineInfo& SCFriendOnlineInfo::operator=(const SCFriendOnlineInfo& other173) {
  onlineStatus = other173.onlineStatus;
  playerData = other173.playerData;
  __isset = other173.__isset;
  return *this;
}
void SCFriendOnlineInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCFriendOnlineInfo(";
  out << "onlineStatus=" << to_string(onlineStatus);
  out << ", " << "playerData=" << to_string(playerData);
  out << ")";
}


CSStartRecord::~CSStartRecord() throw() {
}


uint32_t CSStartRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSStartRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSStartRecord");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSStartRecord &a, CSStartRecord &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSStartRecord::CSStartRecord(const CSStartRecord& other174) {
  (void) other174;
}
CSStartRecord& CSStartRecord::operator=(const CSStartRecord& other175) {
  (void) other175;
  return *this;
}
void CSStartRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSStartRecord(";
  out << ")";
}


SCStartRecord::~SCStartRecord() throw() {
}


void SCStartRecord::__set_result(const int32_t val) {
  this->result = val;
}

void SCStartRecord::__set_userId(const int64_t val) {
  this->userId = val;
}

uint32_t SCStartRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->userId);
          this->__isset.userId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCStartRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCStartRecord");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userId", ::apache::thrift::protocol::T_I64, 20);
  xfer += oprot->writeI64(this->userId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCStartRecord &a, SCStartRecord &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.userId, b.userId);
  swap(a.__isset, b.__isset);
}

SCStartRecord::SCStartRecord(const SCStartRecord& other176) {
  result = other176.result;
  userId = other176.userId;
  __isset = other176.__isset;
}
SCStartRecord& SCStartRecord::operator=(const SCStartRecord& other177) {
  result = other177.result;
  userId = other177.userId;
  __isset = other177.__isset;
  return *this;
}
void SCStartRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCStartRecord(";
  out << "result=" << to_string(result);
  out << ", " << "userId=" << to_string(userId);
  out << ")";
}


CSEndRecord::~CSEndRecord() throw() {
}


void CSEndRecord::__set_url(const std::string& val) {
  this->url = val;
}

void CSEndRecord::__set_timeLength(const double val) {
  this->timeLength = val;
}

uint32_t CSEndRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->timeLength);
          this->__isset.timeLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSEndRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSEndRecord");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeLength", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->timeLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSEndRecord &a, CSEndRecord &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.timeLength, b.timeLength);
  swap(a.__isset, b.__isset);
}

CSEndRecord::CSEndRecord(const CSEndRecord& other178) {
  url = other178.url;
  timeLength = other178.timeLength;
  __isset = other178.__isset;
}
CSEndRecord& CSEndRecord::operator=(const CSEndRecord& other179) {
  url = other179.url;
  timeLength = other179.timeLength;
  __isset = other179.__isset;
  return *this;
}
void CSEndRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSEndRecord(";
  out << "url=" << to_string(url);
  out << ", " << "timeLength=" << to_string(timeLength);
  out << ")";
}


SCEndRecord::~SCEndRecord() throw() {
}


void SCEndRecord::__set_url(const std::string& val) {
  this->url = val;
}

void SCEndRecord::__set_timeLength(const double val) {
  this->timeLength = val;
}

uint32_t SCEndRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->timeLength);
          this->__isset.timeLength = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCEndRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCEndRecord");

  xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->url);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("timeLength", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->timeLength);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCEndRecord &a, SCEndRecord &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.timeLength, b.timeLength);
  swap(a.__isset, b.__isset);
}

SCEndRecord::SCEndRecord(const SCEndRecord& other180) {
  url = other180.url;
  timeLength = other180.timeLength;
  __isset = other180.__isset;
}
SCEndRecord& SCEndRecord::operator=(const SCEndRecord& other181) {
  url = other181.url;
  timeLength = other181.timeLength;
  __isset = other181.__isset;
  return *this;
}
void SCEndRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCEndRecord(";
  out << "url=" << to_string(url);
  out << ", " << "timeLength=" << to_string(timeLength);
  out << ")";
}


CSEndPlayRecord::~CSEndPlayRecord() throw() {
}


uint32_t CSEndPlayRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    xfer += iprot->skip(ftype);
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CSEndPlayRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CSEndPlayRecord");

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CSEndPlayRecord &a, CSEndPlayRecord &b) {
  using ::std::swap;
  (void) a;
  (void) b;
}

CSEndPlayRecord::CSEndPlayRecord(const CSEndPlayRecord& other182) {
  (void) other182;
}
CSEndPlayRecord& CSEndPlayRecord::operator=(const CSEndPlayRecord& other183) {
  (void) other183;
  return *this;
}
void CSEndPlayRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CSEndPlayRecord(";
  out << ")";
}


SCEndPlayRecord::~SCEndPlayRecord() throw() {
}


void SCEndPlayRecord::__set_result(const int32_t val) {
  this->result = val;
}

uint32_t SCEndPlayRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->result);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SCEndPlayRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SCEndPlayRecord");

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->result);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SCEndPlayRecord &a, SCEndPlayRecord &b) {
  using ::std::swap;
  swap(a.result, b.result);
  swap(a.__isset, b.__isset);
}

SCEndPlayRecord::SCEndPlayRecord(const SCEndPlayRecord& other184) {
  result = other184.result;
  __isset = other184.__isset;
}
SCEndPlayRecord& SCEndPlayRecord::operator=(const SCEndPlayRecord& other185) {
  result = other185.result;
  __isset = other185.__isset;
  return *this;
}
void SCEndPlayRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SCEndPlayRecord(";
  out << "result=" << to_string(result);
  out << ")";
}


