/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Map_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kTileTypeValues[] = {
  TileType::None,
  TileType::Static,
  TileType::Trigger,
  TileType::NPC,
  TileType::PlayerStart,
  TileType::SavePoint
};
const char* _kTileTypeNames[] = {
  "None",
  "Static",
  "Trigger",
  "NPC",
  "PlayerStart",
  "SavePoint"
};
const std::map<int, const char*> _TileType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(6, _kTileTypeValues, _kTileTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


TileConfig::~TileConfig() throw() {
}


void TileConfig::__set_name(const std::string& val) {
  this->name = val;
}

void TileConfig::__set_width(const int32_t val) {
  this->width = val;
}

void TileConfig::__set_height(const int32_t val) {
  this->height = val;
}

void TileConfig::__set_depth(const int32_t val) {
  this->depth = val;
}

void TileConfig::__set_resource(const std::string& val) {
  this->resource = val;
}

void TileConfig::__set_type1(const int32_t val) {
  this->type1 = val;
}

void TileConfig::__set_type2(const int32_t val) {
  this->type2 = val;
}

void TileConfig::__set_func(const std::string& val) {
  this->func = val;
}

void TileConfig::__set_rad(const double val) {
  this->rad = val;
}

void TileConfig::__set_overlapFog(const bool val) {
  this->overlapFog = val;
}

uint32_t TileConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->width);
          this->__isset.width = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->height);
          this->__isset.height = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->depth);
          this->__isset.depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource);
          this->__isset.resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type1);
          this->__isset.type1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type2);
          this->__isset.type2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->func);
          this->__isset.func = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->rad);
          this->__isset.rad = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->overlapFog);
          this->__isset.overlapFog = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TileConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TileConfig");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("width", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->width);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("height", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->height);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("depth", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->resource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type1", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->type1);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type2", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->type2);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("func", ::apache::thrift::protocol::T_STRING, 80);
  xfer += oprot->writeString(this->func);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rad", ::apache::thrift::protocol::T_DOUBLE, 90);
  xfer += oprot->writeDouble(this->rad);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("overlapFog", ::apache::thrift::protocol::T_BOOL, 100);
  xfer += oprot->writeBool(this->overlapFog);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TileConfig &a, TileConfig &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.width, b.width);
  swap(a.height, b.height);
  swap(a.depth, b.depth);
  swap(a.resource, b.resource);
  swap(a.type1, b.type1);
  swap(a.type2, b.type2);
  swap(a.func, b.func);
  swap(a.rad, b.rad);
  swap(a.overlapFog, b.overlapFog);
  swap(a.__isset, b.__isset);
}

TileConfig::TileConfig(const TileConfig& other0) {
  name = other0.name;
  width = other0.width;
  height = other0.height;
  depth = other0.depth;
  resource = other0.resource;
  type1 = other0.type1;
  type2 = other0.type2;
  func = other0.func;
  rad = other0.rad;
  overlapFog = other0.overlapFog;
  __isset = other0.__isset;
}
TileConfig& TileConfig::operator=(const TileConfig& other1) {
  name = other1.name;
  width = other1.width;
  height = other1.height;
  depth = other1.depth;
  resource = other1.resource;
  type1 = other1.type1;
  type2 = other1.type2;
  func = other1.func;
  rad = other1.rad;
  overlapFog = other1.overlapFog;
  __isset = other1.__isset;
  return *this;
}
void TileConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TileConfig(";
  out << "name=" << to_string(name);
  out << ", " << "width=" << to_string(width);
  out << ", " << "height=" << to_string(height);
  out << ", " << "depth=" << to_string(depth);
  out << ", " << "resource=" << to_string(resource);
  out << ", " << "type1=" << to_string(type1);
  out << ", " << "type2=" << to_string(type2);
  out << ", " << "func=" << to_string(func);
  out << ", " << "rad=" << to_string(rad);
  out << ", " << "overlapFog=" << to_string(overlapFog);
  out << ")";
}


TileConfigList::~TileConfigList() throw() {
}


void TileConfigList::__set_tileList(const std::vector<TileConfig> & val) {
  this->tileList = val;
}

uint32_t TileConfigList::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tileList.clear();
            uint32_t _size2;
            ::apache::thrift::protocol::TType _etype5;
            xfer += iprot->readListBegin(_etype5, _size2);
            this->tileList.resize(_size2);
            uint32_t _i6;
            for (_i6 = 0; _i6 < _size2; ++_i6)
            {
              xfer += this->tileList[_i6].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tileList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TileConfigList::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TileConfigList");

  xfer += oprot->writeFieldBegin("tileList", ::apache::thrift::protocol::T_LIST, 10);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tileList.size()));
    std::vector<TileConfig> ::const_iterator _iter7;
    for (_iter7 = this->tileList.begin(); _iter7 != this->tileList.end(); ++_iter7)
    {
      xfer += (*_iter7).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TileConfigList &a, TileConfigList &b) {
  using ::std::swap;
  swap(a.tileList, b.tileList);
  swap(a.__isset, b.__isset);
}

TileConfigList::TileConfigList(const TileConfigList& other8) {
  tileList = other8.tileList;
  __isset = other8.__isset;
}
TileConfigList& TileConfigList::operator=(const TileConfigList& other9) {
  tileList = other9.tileList;
  __isset = other9.__isset;
  return *this;
}
void TileConfigList::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TileConfigList(";
  out << "tileList=" << to_string(tileList);
  out << ")";
}


TileData::~TileData() throw() {
}


void TileData::__set_id(const int32_t val) {
  this->id = val;
}

void TileData::__set_name(const std::string& val) {
  this->name = val;
}

void TileData::__set_resource(const std::string& val) {
  this->resource = val;
}

void TileData::__set_x(const double val) {
  this->x = val;
}

void TileData::__set_y(const double val) {
  this->y = val;
}

void TileData::__set_z(const double val) {
  this->z = val;
}

void TileData::__set_depth(const double val) {
  this->depth = val;
}

void TileData::__set_type(const TileType::type val) {
  this->type = val;
}

uint32_t TileData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resource);
          this->__isset.resource = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->depth);
          this->__isset.depth = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast10;
          xfer += iprot->readI32(ecast10);
          this->type = (TileType::type)ecast10;
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TileData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TileData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resource", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->resource);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 40);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 50);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 60);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("depth", ::apache::thrift::protocol::T_DOUBLE, 70);
  xfer += oprot->writeDouble(this->depth);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32((int32_t)this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TileData &a, TileData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.resource, b.resource);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.depth, b.depth);
  swap(a.type, b.type);
  swap(a.__isset, b.__isset);
}

TileData::TileData(const TileData& other11) {
  id = other11.id;
  name = other11.name;
  resource = other11.resource;
  x = other11.x;
  y = other11.y;
  z = other11.z;
  depth = other11.depth;
  type = other11.type;
  __isset = other11.__isset;
}
TileData& TileData::operator=(const TileData& other12) {
  id = other12.id;
  name = other12.name;
  resource = other12.resource;
  x = other12.x;
  y = other12.y;
  z = other12.z;
  depth = other12.depth;
  type = other12.type;
  __isset = other12.__isset;
  return *this;
}
void TileData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TileData(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "resource=" << to_string(resource);
  out << ", " << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ", " << "depth=" << to_string(depth);
  out << ", " << "type=" << to_string(type);
  out << ")";
}


ChunkData::~ChunkData() throw() {
}


void ChunkData::__set_id(const int32_t val) {
  this->id = val;
}

void ChunkData::__set_x(const double val) {
  this->x = val;
}

void ChunkData::__set_y(const double val) {
  this->y = val;
}

void ChunkData::__set_z(const double val) {
  this->z = val;
}

void ChunkData::__set_tiles(const std::vector<TileData> & val) {
  this->tiles = val;
}

uint32_t ChunkData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->x);
          this->__isset.x = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->y);
          this->__isset.y = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->z);
          this->__isset.z = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->tiles.clear();
            uint32_t _size13;
            ::apache::thrift::protocol::TType _etype16;
            xfer += iprot->readListBegin(_etype16, _size13);
            this->tiles.resize(_size13);
            uint32_t _i17;
            for (_i17 = 0; _i17 < _size13; ++_i17)
            {
              xfer += this->tiles[_i17].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.tiles = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChunkData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChunkData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("x", ::apache::thrift::protocol::T_DOUBLE, 10);
  xfer += oprot->writeDouble(this->x);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("y", ::apache::thrift::protocol::T_DOUBLE, 20);
  xfer += oprot->writeDouble(this->y);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("z", ::apache::thrift::protocol::T_DOUBLE, 30);
  xfer += oprot->writeDouble(this->z);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("tiles", ::apache::thrift::protocol::T_LIST, 40);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->tiles.size()));
    std::vector<TileData> ::const_iterator _iter18;
    for (_iter18 = this->tiles.begin(); _iter18 != this->tiles.end(); ++_iter18)
    {
      xfer += (*_iter18).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChunkData &a, ChunkData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.x, b.x);
  swap(a.y, b.y);
  swap(a.z, b.z);
  swap(a.tiles, b.tiles);
  swap(a.__isset, b.__isset);
}

ChunkData::ChunkData(const ChunkData& other19) {
  id = other19.id;
  x = other19.x;
  y = other19.y;
  z = other19.z;
  tiles = other19.tiles;
  __isset = other19.__isset;
}
ChunkData& ChunkData::operator=(const ChunkData& other20) {
  id = other20.id;
  x = other20.x;
  y = other20.y;
  z = other20.z;
  tiles = other20.tiles;
  __isset = other20.__isset;
  return *this;
}
void ChunkData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChunkData(";
  out << "id=" << to_string(id);
  out << ", " << "x=" << to_string(x);
  out << ", " << "y=" << to_string(y);
  out << ", " << "z=" << to_string(z);
  out << ", " << "tiles=" << to_string(tiles);
  out << ")";
}


MapData::~MapData() throw() {
}


void MapData::__set_id(const int32_t val) {
  this->id = val;
}

void MapData::__set_name(const std::string& val) {
  this->name = val;
}

void MapData::__set_chunks(const std::vector<ChunkData> & val) {
  this->chunks = val;
}

uint32_t MapData::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->chunks.clear();
            uint32_t _size21;
            ::apache::thrift::protocol::TType _etype24;
            xfer += iprot->readListBegin(_etype24, _size21);
            this->chunks.resize(_size21);
            uint32_t _i25;
            for (_i25 = 0; _i25 < _size21; ++_i25)
            {
              xfer += this->chunks[_i25].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.chunks = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MapData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MapData");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chunks", ::apache::thrift::protocol::T_LIST, 30);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->chunks.size()));
    std::vector<ChunkData> ::const_iterator _iter26;
    for (_iter26 = this->chunks.begin(); _iter26 != this->chunks.end(); ++_iter26)
    {
      xfer += (*_iter26).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MapData &a, MapData &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.chunks, b.chunks);
  swap(a.__isset, b.__isset);
}

MapData::MapData(const MapData& other27) {
  id = other27.id;
  name = other27.name;
  chunks = other27.chunks;
  __isset = other27.__isset;
}
MapData& MapData::operator=(const MapData& other28) {
  id = other28.id;
  name = other28.name;
  chunks = other28.chunks;
  __isset = other28.__isset;
  return *this;
}
void MapData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MapData(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "chunks=" << to_string(chunks);
  out << ")";
}


