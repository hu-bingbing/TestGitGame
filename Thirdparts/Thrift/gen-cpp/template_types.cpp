/**
 * Autogenerated by Thrift Compiler (@PACKAGE_VERSION@)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "template_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace CytxGame {


PlayerAttrConfig::~PlayerAttrConfig() throw() {
}


void PlayerAttrConfig::__set_initHp(const int32_t val) {
  this->initHp = val;
}

void PlayerAttrConfig::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

void PlayerAttrConfig::__set_moveSpeed(const int32_t val) {
  this->moveSpeed = val;
}

void PlayerAttrConfig::__set_jumpSpeed(const int32_t val) {
  this->jumpSpeed = val;
}

void PlayerAttrConfig::__set_guardDuration(const int32_t val) {
  this->guardDuration = val;
}

uint32_t PlayerAttrConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initHp);
          this->__isset.initHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->moveSpeed);
          this->__isset.moveSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->jumpSpeed);
          this->__isset.jumpSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->guardDuration);
          this->__isset.guardDuration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PlayerAttrConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PlayerAttrConfig");

  xfer += oprot->writeFieldBegin("initHp", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->initHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("moveSpeed", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->moveSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("jumpSpeed", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->jumpSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guardDuration", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->guardDuration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PlayerAttrConfig &a, PlayerAttrConfig &b) {
  using ::std::swap;
  swap(a.initHp, b.initHp);
  swap(a.maxHp, b.maxHp);
  swap(a.moveSpeed, b.moveSpeed);
  swap(a.jumpSpeed, b.jumpSpeed);
  swap(a.guardDuration, b.guardDuration);
  swap(a.__isset, b.__isset);
}

PlayerAttrConfig::PlayerAttrConfig(const PlayerAttrConfig& other0) {
  initHp = other0.initHp;
  maxHp = other0.maxHp;
  moveSpeed = other0.moveSpeed;
  jumpSpeed = other0.jumpSpeed;
  guardDuration = other0.guardDuration;
  __isset = other0.__isset;
}
PlayerAttrConfig& PlayerAttrConfig::operator=(const PlayerAttrConfig& other1) {
  initHp = other1.initHp;
  maxHp = other1.maxHp;
  moveSpeed = other1.moveSpeed;
  jumpSpeed = other1.jumpSpeed;
  guardDuration = other1.guardDuration;
  __isset = other1.__isset;
  return *this;
}
void PlayerAttrConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PlayerAttrConfig(";
  out << "initHp=" << to_string(initHp);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ", " << "moveSpeed=" << to_string(moveSpeed);
  out << ", " << "jumpSpeed=" << to_string(jumpSpeed);
  out << ", " << "guardDuration=" << to_string(guardDuration);
  out << ")";
}


MagicPlayerAttrConfig::~MagicPlayerAttrConfig() throw() {
}


void MagicPlayerAttrConfig::__set_initMana(const int32_t val) {
  this->initMana = val;
}

void MagicPlayerAttrConfig::__set_maxMana(const int32_t val) {
  this->maxMana = val;
}

void MagicPlayerAttrConfig::__set_initChopCost(const int32_t val) {
  this->initChopCost = val;
}

void MagicPlayerAttrConfig::__set_ChopCostAdd(const int32_t val) {
  this->ChopCostAdd = val;
}

void MagicPlayerAttrConfig::__set_maxChopCost(const int32_t val) {
  this->maxChopCost = val;
}

void MagicPlayerAttrConfig::__set_blowCost(const int32_t val) {
  this->blowCost = val;
}

void MagicPlayerAttrConfig::__set_minFogRadius(const int32_t val) {
  this->minFogRadius = val;
}

void MagicPlayerAttrConfig::__set_maxFogRadius(const int32_t val) {
  this->maxFogRadius = val;
}

void MagicPlayerAttrConfig::__set_manaTimer(const int32_t val) {
  this->manaTimer = val;
}

void MagicPlayerAttrConfig::__set_winduration(const int32_t val) {
  this->winduration = val;
}

void MagicPlayerAttrConfig::__set_isFireMode(const bool val) {
  this->isFireMode = val;
}

void MagicPlayerAttrConfig::__set_blowCdTime(const int32_t val) {
  this->blowCdTime = val;
}

uint32_t MagicPlayerAttrConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initMana);
          this->__isset.initMana = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxMana);
          this->__isset.maxMana = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initChopCost);
          this->__isset.initChopCost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ChopCostAdd);
          this->__isset.ChopCostAdd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxChopCost);
          this->__isset.maxChopCost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blowCost);
          this->__isset.blowCost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minFogRadius);
          this->__isset.minFogRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxFogRadius);
          this->__isset.maxFogRadius = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->manaTimer);
          this->__isset.manaTimer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->winduration);
          this->__isset.winduration = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->isFireMode);
          this->__isset.isFireMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blowCdTime);
          this->__isset.blowCdTime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t MagicPlayerAttrConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("MagicPlayerAttrConfig");

  xfer += oprot->writeFieldBegin("initMana", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->initMana);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxMana", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->maxMana);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initChopCost", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->initChopCost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ChopCostAdd", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->ChopCostAdd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxChopCost", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->maxChopCost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blowCost", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->blowCost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("minFogRadius", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->minFogRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxFogRadius", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->maxFogRadius);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("manaTimer", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->manaTimer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("winduration", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->winduration);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("isFireMode", ::apache::thrift::protocol::T_BOOL, 110);
  xfer += oprot->writeBool(this->isFireMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blowCdTime", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->blowCdTime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(MagicPlayerAttrConfig &a, MagicPlayerAttrConfig &b) {
  using ::std::swap;
  swap(a.initMana, b.initMana);
  swap(a.maxMana, b.maxMana);
  swap(a.initChopCost, b.initChopCost);
  swap(a.ChopCostAdd, b.ChopCostAdd);
  swap(a.maxChopCost, b.maxChopCost);
  swap(a.blowCost, b.blowCost);
  swap(a.minFogRadius, b.minFogRadius);
  swap(a.maxFogRadius, b.maxFogRadius);
  swap(a.manaTimer, b.manaTimer);
  swap(a.winduration, b.winduration);
  swap(a.isFireMode, b.isFireMode);
  swap(a.blowCdTime, b.blowCdTime);
  swap(a.__isset, b.__isset);
}

MagicPlayerAttrConfig::MagicPlayerAttrConfig(const MagicPlayerAttrConfig& other2) {
  initMana = other2.initMana;
  maxMana = other2.maxMana;
  initChopCost = other2.initChopCost;
  ChopCostAdd = other2.ChopCostAdd;
  maxChopCost = other2.maxChopCost;
  blowCost = other2.blowCost;
  minFogRadius = other2.minFogRadius;
  maxFogRadius = other2.maxFogRadius;
  manaTimer = other2.manaTimer;
  winduration = other2.winduration;
  isFireMode = other2.isFireMode;
  blowCdTime = other2.blowCdTime;
  __isset = other2.__isset;
}
MagicPlayerAttrConfig& MagicPlayerAttrConfig::operator=(const MagicPlayerAttrConfig& other3) {
  initMana = other3.initMana;
  maxMana = other3.maxMana;
  initChopCost = other3.initChopCost;
  ChopCostAdd = other3.ChopCostAdd;
  maxChopCost = other3.maxChopCost;
  blowCost = other3.blowCost;
  minFogRadius = other3.minFogRadius;
  maxFogRadius = other3.maxFogRadius;
  manaTimer = other3.manaTimer;
  winduration = other3.winduration;
  isFireMode = other3.isFireMode;
  blowCdTime = other3.blowCdTime;
  __isset = other3.__isset;
  return *this;
}
void MagicPlayerAttrConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "MagicPlayerAttrConfig(";
  out << "initMana=" << to_string(initMana);
  out << ", " << "maxMana=" << to_string(maxMana);
  out << ", " << "initChopCost=" << to_string(initChopCost);
  out << ", " << "ChopCostAdd=" << to_string(ChopCostAdd);
  out << ", " << "maxChopCost=" << to_string(maxChopCost);
  out << ", " << "blowCost=" << to_string(blowCost);
  out << ", " << "minFogRadius=" << to_string(minFogRadius);
  out << ", " << "maxFogRadius=" << to_string(maxFogRadius);
  out << ", " << "manaTimer=" << to_string(manaTimer);
  out << ", " << "winduration=" << to_string(winduration);
  out << ", " << "isFireMode=" << to_string(isFireMode);
  out << ", " << "blowCdTime=" << to_string(blowCdTime);
  out << ")";
}


CreatureAttrConfig::~CreatureAttrConfig() throw() {
}


void CreatureAttrConfig::__set_id(const int32_t val) {
  this->id = val;
}

void CreatureAttrConfig::__set_name(const std::string& val) {
  this->name = val;
}

void CreatureAttrConfig::__set_type(const int32_t val) {
  this->type = val;
}

void CreatureAttrConfig::__set_initHp(const int32_t val) {
  this->initHp = val;
}

void CreatureAttrConfig::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

void CreatureAttrConfig::__set_patrolSpeed(const int32_t val) {
  this->patrolSpeed = val;
}

void CreatureAttrConfig::__set_chaseSpeed(const int32_t val) {
  this->chaseSpeed = val;
}

void CreatureAttrConfig::__set_attackSpeed(const int32_t val) {
  this->attackSpeed = val;
}

void CreatureAttrConfig::__set_guardArea(const int32_t val) {
  this->guardArea = val;
}

void CreatureAttrConfig::__set_attackArea(const int32_t val) {
  this->attackArea = val;
}

void CreatureAttrConfig::__set_aiMode(const int32_t val) {
  this->aiMode = val;
}

void CreatureAttrConfig::__set_assetBundle(const std::string& val) {
  this->assetBundle = val;
}

void CreatureAttrConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void CreatureAttrConfig::__set_bonusStrategy(const int32_t val) {
  this->bonusStrategy = val;
}

uint32_t CreatureAttrConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initHp);
          this->__isset.initHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->patrolSpeed);
          this->__isset.patrolSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->chaseSpeed);
          this->__isset.chaseSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attackSpeed);
          this->__isset.attackSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->guardArea);
          this->__isset.guardArea = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attackArea);
          this->__isset.attackArea = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->aiMode);
          this->__isset.aiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->assetBundle);
          this->__isset.assetBundle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 120:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bonusStrategy);
          this->__isset.bonusStrategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreatureAttrConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreatureAttrConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initHp", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->initHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("patrolSpeed", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->patrolSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chaseSpeed", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->chaseSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackSpeed", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->attackSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("guardArea", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->guardArea);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackArea", ::apache::thrift::protocol::T_I32, 80);
  xfer += oprot->writeI32(this->attackArea);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aiMode", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->aiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("assetBundle", ::apache::thrift::protocol::T_STRING, 100);
  xfer += oprot->writeString(this->assetBundle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 110);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bonusStrategy", ::apache::thrift::protocol::T_I32, 120);
  xfer += oprot->writeI32(this->bonusStrategy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreatureAttrConfig &a, CreatureAttrConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.initHp, b.initHp);
  swap(a.maxHp, b.maxHp);
  swap(a.patrolSpeed, b.patrolSpeed);
  swap(a.chaseSpeed, b.chaseSpeed);
  swap(a.attackSpeed, b.attackSpeed);
  swap(a.guardArea, b.guardArea);
  swap(a.attackArea, b.attackArea);
  swap(a.aiMode, b.aiMode);
  swap(a.assetBundle, b.assetBundle);
  swap(a.sourceName, b.sourceName);
  swap(a.bonusStrategy, b.bonusStrategy);
  swap(a.__isset, b.__isset);
}

CreatureAttrConfig::CreatureAttrConfig(const CreatureAttrConfig& other4) {
  id = other4.id;
  name = other4.name;
  type = other4.type;
  initHp = other4.initHp;
  maxHp = other4.maxHp;
  patrolSpeed = other4.patrolSpeed;
  chaseSpeed = other4.chaseSpeed;
  attackSpeed = other4.attackSpeed;
  guardArea = other4.guardArea;
  attackArea = other4.attackArea;
  aiMode = other4.aiMode;
  assetBundle = other4.assetBundle;
  sourceName = other4.sourceName;
  bonusStrategy = other4.bonusStrategy;
  __isset = other4.__isset;
}
CreatureAttrConfig& CreatureAttrConfig::operator=(const CreatureAttrConfig& other5) {
  id = other5.id;
  name = other5.name;
  type = other5.type;
  initHp = other5.initHp;
  maxHp = other5.maxHp;
  patrolSpeed = other5.patrolSpeed;
  chaseSpeed = other5.chaseSpeed;
  attackSpeed = other5.attackSpeed;
  guardArea = other5.guardArea;
  attackArea = other5.attackArea;
  aiMode = other5.aiMode;
  assetBundle = other5.assetBundle;
  sourceName = other5.sourceName;
  bonusStrategy = other5.bonusStrategy;
  __isset = other5.__isset;
  return *this;
}
void CreatureAttrConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreatureAttrConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "initHp=" << to_string(initHp);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ", " << "patrolSpeed=" << to_string(patrolSpeed);
  out << ", " << "chaseSpeed=" << to_string(chaseSpeed);
  out << ", " << "attackSpeed=" << to_string(attackSpeed);
  out << ", " << "guardArea=" << to_string(guardArea);
  out << ", " << "attackArea=" << to_string(attackArea);
  out << ", " << "aiMode=" << to_string(aiMode);
  out << ", " << "assetBundle=" << to_string(assetBundle);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "bonusStrategy=" << to_string(bonusStrategy);
  out << ")";
}


CreatureAttrConfigTable::~CreatureAttrConfigTable() throw() {
}


void CreatureAttrConfigTable::__set_creatureConfigMap(const std::map<int32_t, CreatureAttrConfig> & val) {
  this->creatureConfigMap = val;
}

uint32_t CreatureAttrConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->creatureConfigMap.clear();
            uint32_t _size6;
            ::apache::thrift::protocol::TType _ktype7;
            ::apache::thrift::protocol::TType _vtype8;
            xfer += iprot->readMapBegin(_ktype7, _vtype8, _size6);
            uint32_t _i10;
            for (_i10 = 0; _i10 < _size6; ++_i10)
            {
              int32_t _key11;
              xfer += iprot->readI32(_key11);
              CreatureAttrConfig& _val12 = this->creatureConfigMap[_key11];
              xfer += _val12.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.creatureConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CreatureAttrConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CreatureAttrConfigTable");

  xfer += oprot->writeFieldBegin("creatureConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->creatureConfigMap.size()));
    std::map<int32_t, CreatureAttrConfig> ::const_iterator _iter13;
    for (_iter13 = this->creatureConfigMap.begin(); _iter13 != this->creatureConfigMap.end(); ++_iter13)
    {
      xfer += oprot->writeI32(_iter13->first);
      xfer += _iter13->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CreatureAttrConfigTable &a, CreatureAttrConfigTable &b) {
  using ::std::swap;
  swap(a.creatureConfigMap, b.creatureConfigMap);
  swap(a.__isset, b.__isset);
}

CreatureAttrConfigTable::CreatureAttrConfigTable(const CreatureAttrConfigTable& other14) {
  creatureConfigMap = other14.creatureConfigMap;
  __isset = other14.__isset;
}
CreatureAttrConfigTable& CreatureAttrConfigTable::operator=(const CreatureAttrConfigTable& other15) {
  creatureConfigMap = other15.creatureConfigMap;
  __isset = other15.__isset;
  return *this;
}
void CreatureAttrConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CreatureAttrConfigTable(";
  out << "creatureConfigMap=" << to_string(creatureConfigMap);
  out << ")";
}


PetAttrConfig::~PetAttrConfig() throw() {
}


void PetAttrConfig::__set_id(const int32_t val) {
  this->id = val;
}

void PetAttrConfig::__set_name(const std::string& val) {
  this->name = val;
}

void PetAttrConfig::__set_type(const int32_t val) {
  this->type = val;
}

void PetAttrConfig::__set_initHp(const int32_t val) {
  this->initHp = val;
}

void PetAttrConfig::__set_maxHp(const int32_t val) {
  this->maxHp = val;
}

void PetAttrConfig::__set_aiMode(const int32_t val) {
  this->aiMode = val;
}

void PetAttrConfig::__set_assetBundle(const std::string& val) {
  this->assetBundle = val;
}

void PetAttrConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void PetAttrConfig::__set_fellowSpeed(const int32_t val) {
  this->fellowSpeed = val;
}

void PetAttrConfig::__set_chaseSpeed(const int32_t val) {
  this->chaseSpeed = val;
}

void PetAttrConfig::__set_attackSpeed(const int32_t val) {
  this->attackSpeed = val;
}

uint32_t PetAttrConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->initHp);
          this->__isset.initHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxHp);
          this->__isset.maxHp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->aiMode);
          this->__isset.aiMode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->assetBundle);
          this->__isset.assetBundle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->fellowSpeed);
          this->__isset.fellowSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 100:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->chaseSpeed);
          this->__isset.chaseSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 110:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->attackSpeed);
          this->__isset.attackSpeed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetAttrConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PetAttrConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("initHp", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->initHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("maxHp", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->maxHp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aiMode", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->aiMode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("assetBundle", ::apache::thrift::protocol::T_STRING, 70);
  xfer += oprot->writeString(this->assetBundle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 80);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("fellowSpeed", ::apache::thrift::protocol::T_I32, 90);
  xfer += oprot->writeI32(this->fellowSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("chaseSpeed", ::apache::thrift::protocol::T_I32, 100);
  xfer += oprot->writeI32(this->chaseSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("attackSpeed", ::apache::thrift::protocol::T_I32, 110);
  xfer += oprot->writeI32(this->attackSpeed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetAttrConfig &a, PetAttrConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.initHp, b.initHp);
  swap(a.maxHp, b.maxHp);
  swap(a.aiMode, b.aiMode);
  swap(a.assetBundle, b.assetBundle);
  swap(a.sourceName, b.sourceName);
  swap(a.fellowSpeed, b.fellowSpeed);
  swap(a.chaseSpeed, b.chaseSpeed);
  swap(a.attackSpeed, b.attackSpeed);
  swap(a.__isset, b.__isset);
}

PetAttrConfig::PetAttrConfig(const PetAttrConfig& other16) {
  id = other16.id;
  name = other16.name;
  type = other16.type;
  initHp = other16.initHp;
  maxHp = other16.maxHp;
  aiMode = other16.aiMode;
  assetBundle = other16.assetBundle;
  sourceName = other16.sourceName;
  fellowSpeed = other16.fellowSpeed;
  chaseSpeed = other16.chaseSpeed;
  attackSpeed = other16.attackSpeed;
  __isset = other16.__isset;
}
PetAttrConfig& PetAttrConfig::operator=(const PetAttrConfig& other17) {
  id = other17.id;
  name = other17.name;
  type = other17.type;
  initHp = other17.initHp;
  maxHp = other17.maxHp;
  aiMode = other17.aiMode;
  assetBundle = other17.assetBundle;
  sourceName = other17.sourceName;
  fellowSpeed = other17.fellowSpeed;
  chaseSpeed = other17.chaseSpeed;
  attackSpeed = other17.attackSpeed;
  __isset = other17.__isset;
  return *this;
}
void PetAttrConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PetAttrConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "initHp=" << to_string(initHp);
  out << ", " << "maxHp=" << to_string(maxHp);
  out << ", " << "aiMode=" << to_string(aiMode);
  out << ", " << "assetBundle=" << to_string(assetBundle);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "fellowSpeed=" << to_string(fellowSpeed);
  out << ", " << "chaseSpeed=" << to_string(chaseSpeed);
  out << ", " << "attackSpeed=" << to_string(attackSpeed);
  out << ")";
}


PetAttrConfigTable::~PetAttrConfigTable() throw() {
}


void PetAttrConfigTable::__set_petConfigMap(const std::map<int32_t, PetAttrConfig> & val) {
  this->petConfigMap = val;
}

uint32_t PetAttrConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->petConfigMap.clear();
            uint32_t _size18;
            ::apache::thrift::protocol::TType _ktype19;
            ::apache::thrift::protocol::TType _vtype20;
            xfer += iprot->readMapBegin(_ktype19, _vtype20, _size18);
            uint32_t _i22;
            for (_i22 = 0; _i22 < _size18; ++_i22)
            {
              int32_t _key23;
              xfer += iprot->readI32(_key23);
              PetAttrConfig& _val24 = this->petConfigMap[_key23];
              xfer += _val24.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.petConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PetAttrConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PetAttrConfigTable");

  xfer += oprot->writeFieldBegin("petConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->petConfigMap.size()));
    std::map<int32_t, PetAttrConfig> ::const_iterator _iter25;
    for (_iter25 = this->petConfigMap.begin(); _iter25 != this->petConfigMap.end(); ++_iter25)
    {
      xfer += oprot->writeI32(_iter25->first);
      xfer += _iter25->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PetAttrConfigTable &a, PetAttrConfigTable &b) {
  using ::std::swap;
  swap(a.petConfigMap, b.petConfigMap);
  swap(a.__isset, b.__isset);
}

PetAttrConfigTable::PetAttrConfigTable(const PetAttrConfigTable& other26) {
  petConfigMap = other26.petConfigMap;
  __isset = other26.__isset;
}
PetAttrConfigTable& PetAttrConfigTable::operator=(const PetAttrConfigTable& other27) {
  petConfigMap = other27.petConfigMap;
  __isset = other27.__isset;
  return *this;
}
void PetAttrConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PetAttrConfigTable(";
  out << "petConfigMap=" << to_string(petConfigMap);
  out << ")";
}


DungeonConfig::~DungeonConfig() throw() {
}


void DungeonConfig::__set_id(const int32_t val) {
  this->id = val;
}

void DungeonConfig::__set_name(const std::string& val) {
  this->name = val;
}

void DungeonConfig::__set_icon(const std::string& val) {
  this->icon = val;
}

void DungeonConfig::__set_mapName(const std::string& val) {
  this->mapName = val;
}

void DungeonConfig::__set_childrenList(const std::vector<ChildDungeonConfig> & val) {
  this->childrenList = val;
}

uint32_t DungeonConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->icon);
          this->__isset.icon = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->mapName);
          this->__isset.mapName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->childrenList.clear();
            uint32_t _size28;
            ::apache::thrift::protocol::TType _etype31;
            xfer += iprot->readListBegin(_etype31, _size28);
            this->childrenList.resize(_size28);
            uint32_t _i32;
            for (_i32 = 0; _i32 < _size28; ++_i32)
            {
              xfer += this->childrenList[_i32].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.childrenList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DungeonConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DungeonConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("icon", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->icon);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mapName", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->mapName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("childrenList", ::apache::thrift::protocol::T_LIST, 50);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->childrenList.size()));
    std::vector<ChildDungeonConfig> ::const_iterator _iter33;
    for (_iter33 = this->childrenList.begin(); _iter33 != this->childrenList.end(); ++_iter33)
    {
      xfer += (*_iter33).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DungeonConfig &a, DungeonConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.icon, b.icon);
  swap(a.mapName, b.mapName);
  swap(a.childrenList, b.childrenList);
  swap(a.__isset, b.__isset);
}

DungeonConfig::DungeonConfig(const DungeonConfig& other34) {
  id = other34.id;
  name = other34.name;
  icon = other34.icon;
  mapName = other34.mapName;
  childrenList = other34.childrenList;
  __isset = other34.__isset;
}
DungeonConfig& DungeonConfig::operator=(const DungeonConfig& other35) {
  id = other35.id;
  name = other35.name;
  icon = other35.icon;
  mapName = other35.mapName;
  childrenList = other35.childrenList;
  __isset = other35.__isset;
  return *this;
}
void DungeonConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DungeonConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "icon=" << to_string(icon);
  out << ", " << "mapName=" << to_string(mapName);
  out << ", " << "childrenList=" << to_string(childrenList);
  out << ")";
}


DungeonConfigTable::~DungeonConfigTable() throw() {
}


void DungeonConfigTable::__set_dungeonConfigMap(const std::map<int32_t, DungeonConfig> & val) {
  this->dungeonConfigMap = val;
}

uint32_t DungeonConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->dungeonConfigMap.clear();
            uint32_t _size36;
            ::apache::thrift::protocol::TType _ktype37;
            ::apache::thrift::protocol::TType _vtype38;
            xfer += iprot->readMapBegin(_ktype37, _vtype38, _size36);
            uint32_t _i40;
            for (_i40 = 0; _i40 < _size36; ++_i40)
            {
              int32_t _key41;
              xfer += iprot->readI32(_key41);
              DungeonConfig& _val42 = this->dungeonConfigMap[_key41];
              xfer += _val42.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.dungeonConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DungeonConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DungeonConfigTable");

  xfer += oprot->writeFieldBegin("dungeonConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->dungeonConfigMap.size()));
    std::map<int32_t, DungeonConfig> ::const_iterator _iter43;
    for (_iter43 = this->dungeonConfigMap.begin(); _iter43 != this->dungeonConfigMap.end(); ++_iter43)
    {
      xfer += oprot->writeI32(_iter43->first);
      xfer += _iter43->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DungeonConfigTable &a, DungeonConfigTable &b) {
  using ::std::swap;
  swap(a.dungeonConfigMap, b.dungeonConfigMap);
  swap(a.__isset, b.__isset);
}

DungeonConfigTable::DungeonConfigTable(const DungeonConfigTable& other44) {
  dungeonConfigMap = other44.dungeonConfigMap;
  __isset = other44.__isset;
}
DungeonConfigTable& DungeonConfigTable::operator=(const DungeonConfigTable& other45) {
  dungeonConfigMap = other45.dungeonConfigMap;
  __isset = other45.__isset;
  return *this;
}
void DungeonConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DungeonConfigTable(";
  out << "dungeonConfigMap=" << to_string(dungeonConfigMap);
  out << ")";
}


ChildDungeonConfig::~ChildDungeonConfig() throw() {
}


void ChildDungeonConfig::__set_id(const int32_t val) {
  this->id = val;
}

void ChildDungeonConfig::__set_name(const std::string& val) {
  this->name = val;
}

void ChildDungeonConfig::__set_resourceName(const std::string& val) {
  this->resourceName = val;
}

uint32_t ChildDungeonConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->resourceName);
          this->__isset.resourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ChildDungeonConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ChildDungeonConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 30);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("resourceName", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->resourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ChildDungeonConfig &a, ChildDungeonConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.resourceName, b.resourceName);
  swap(a.__isset, b.__isset);
}

ChildDungeonConfig::ChildDungeonConfig(const ChildDungeonConfig& other46) {
  id = other46.id;
  name = other46.name;
  resourceName = other46.resourceName;
  __isset = other46.__isset;
}
ChildDungeonConfig& ChildDungeonConfig::operator=(const ChildDungeonConfig& other47) {
  id = other47.id;
  name = other47.name;
  resourceName = other47.resourceName;
  __isset = other47.__isset;
  return *this;
}
void ChildDungeonConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ChildDungeonConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "resourceName=" << to_string(resourceName);
  out << ")";
}


TriggerConfig::~TriggerConfig() throw() {
}


void TriggerConfig::__set_id(const int32_t val) {
  this->id = val;
}

void TriggerConfig::__set_name(const std::string& val) {
  this->name = val;
}

void TriggerConfig::__set_type(const int32_t val) {
  this->type = val;
}

void TriggerConfig::__set_assetBundle(const std::string& val) {
  this->assetBundle = val;
}

void TriggerConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void TriggerConfig::__set_bonusStrategy(const int32_t val) {
  this->bonusStrategy = val;
}

uint32_t TriggerConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->assetBundle);
          this->__isset.assetBundle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->bonusStrategy);
          this->__isset.bonusStrategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TriggerConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TriggerConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 11);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 20);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("assetBundle", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->assetBundle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 60);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("bonusStrategy", ::apache::thrift::protocol::T_I32, 70);
  xfer += oprot->writeI32(this->bonusStrategy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TriggerConfig &a, TriggerConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.assetBundle, b.assetBundle);
  swap(a.sourceName, b.sourceName);
  swap(a.bonusStrategy, b.bonusStrategy);
  swap(a.__isset, b.__isset);
}

TriggerConfig::TriggerConfig(const TriggerConfig& other48) {
  id = other48.id;
  name = other48.name;
  type = other48.type;
  assetBundle = other48.assetBundle;
  sourceName = other48.sourceName;
  bonusStrategy = other48.bonusStrategy;
  __isset = other48.__isset;
}
TriggerConfig& TriggerConfig::operator=(const TriggerConfig& other49) {
  id = other49.id;
  name = other49.name;
  type = other49.type;
  assetBundle = other49.assetBundle;
  sourceName = other49.sourceName;
  bonusStrategy = other49.bonusStrategy;
  __isset = other49.__isset;
  return *this;
}
void TriggerConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TriggerConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "assetBundle=" << to_string(assetBundle);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "bonusStrategy=" << to_string(bonusStrategy);
  out << ")";
}


TriggerConfigTable::~TriggerConfigTable() throw() {
}


void TriggerConfigTable::__set_triggerConfigMap(const std::map<int32_t, TriggerConfig> & val) {
  this->triggerConfigMap = val;
}

uint32_t TriggerConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->triggerConfigMap.clear();
            uint32_t _size50;
            ::apache::thrift::protocol::TType _ktype51;
            ::apache::thrift::protocol::TType _vtype52;
            xfer += iprot->readMapBegin(_ktype51, _vtype52, _size50);
            uint32_t _i54;
            for (_i54 = 0; _i54 < _size50; ++_i54)
            {
              int32_t _key55;
              xfer += iprot->readI32(_key55);
              TriggerConfig& _val56 = this->triggerConfigMap[_key55];
              xfer += _val56.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.triggerConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TriggerConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TriggerConfigTable");

  xfer += oprot->writeFieldBegin("triggerConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->triggerConfigMap.size()));
    std::map<int32_t, TriggerConfig> ::const_iterator _iter57;
    for (_iter57 = this->triggerConfigMap.begin(); _iter57 != this->triggerConfigMap.end(); ++_iter57)
    {
      xfer += oprot->writeI32(_iter57->first);
      xfer += _iter57->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TriggerConfigTable &a, TriggerConfigTable &b) {
  using ::std::swap;
  swap(a.triggerConfigMap, b.triggerConfigMap);
  swap(a.__isset, b.__isset);
}

TriggerConfigTable::TriggerConfigTable(const TriggerConfigTable& other58) {
  triggerConfigMap = other58.triggerConfigMap;
  __isset = other58.__isset;
}
TriggerConfigTable& TriggerConfigTable::operator=(const TriggerConfigTable& other59) {
  triggerConfigMap = other59.triggerConfigMap;
  __isset = other59.__isset;
  return *this;
}
void TriggerConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TriggerConfigTable(";
  out << "triggerConfigMap=" << to_string(triggerConfigMap);
  out << ")";
}


ItemConfig::~ItemConfig() throw() {
}


void ItemConfig::__set_id(const int32_t val) {
  this->id = val;
}

void ItemConfig::__set_name(const std::string& val) {
  this->name = val;
}

void ItemConfig::__set_type(const int32_t val) {
  this->type = val;
}

void ItemConfig::__set_blood(const int32_t val) {
  this->blood = val;
}

void ItemConfig::__set_mana(const int32_t val) {
  this->mana = val;
}

void ItemConfig::__set_light(const int32_t val) {
  this->light = val;
}

void ItemConfig::__set_dataPrefab(const std::string& val) {
  this->dataPrefab = val;
}

void ItemConfig::__set_assetBundle(const std::string& val) {
  this->assetBundle = val;
}

void ItemConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void ItemConfig::__set_dieEffect(const std::string& val) {
  this->dieEffect = val;
}

uint32_t ItemConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 32:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->blood);
          this->__isset.blood = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 34:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mana);
          this->__isset.mana = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 36:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->light);
          this->__isset.light = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dataPrefab);
          this->__isset.dataPrefab = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->assetBundle);
          this->__isset.assetBundle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dieEffect);
          this->__isset.dieEffect = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("blood", ::apache::thrift::protocol::T_I32, 32);
  xfer += oprot->writeI32(this->blood);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mana", ::apache::thrift::protocol::T_I32, 34);
  xfer += oprot->writeI32(this->mana);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("light", ::apache::thrift::protocol::T_I32, 36);
  xfer += oprot->writeI32(this->light);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataPrefab", ::apache::thrift::protocol::T_STRING, 40);
  xfer += oprot->writeString(this->dataPrefab);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("assetBundle", ::apache::thrift::protocol::T_STRING, 50);
  xfer += oprot->writeString(this->assetBundle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 60);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dieEffect", ::apache::thrift::protocol::T_STRING, 70);
  xfer += oprot->writeString(this->dieEffect);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemConfig &a, ItemConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.blood, b.blood);
  swap(a.mana, b.mana);
  swap(a.light, b.light);
  swap(a.dataPrefab, b.dataPrefab);
  swap(a.assetBundle, b.assetBundle);
  swap(a.sourceName, b.sourceName);
  swap(a.dieEffect, b.dieEffect);
  swap(a.__isset, b.__isset);
}

ItemConfig::ItemConfig(const ItemConfig& other60) {
  id = other60.id;
  name = other60.name;
  type = other60.type;
  blood = other60.blood;
  mana = other60.mana;
  light = other60.light;
  dataPrefab = other60.dataPrefab;
  assetBundle = other60.assetBundle;
  sourceName = other60.sourceName;
  dieEffect = other60.dieEffect;
  __isset = other60.__isset;
}
ItemConfig& ItemConfig::operator=(const ItemConfig& other61) {
  id = other61.id;
  name = other61.name;
  type = other61.type;
  blood = other61.blood;
  mana = other61.mana;
  light = other61.light;
  dataPrefab = other61.dataPrefab;
  assetBundle = other61.assetBundle;
  sourceName = other61.sourceName;
  dieEffect = other61.dieEffect;
  __isset = other61.__isset;
  return *this;
}
void ItemConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "blood=" << to_string(blood);
  out << ", " << "mana=" << to_string(mana);
  out << ", " << "light=" << to_string(light);
  out << ", " << "dataPrefab=" << to_string(dataPrefab);
  out << ", " << "assetBundle=" << to_string(assetBundle);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "dieEffect=" << to_string(dieEffect);
  out << ")";
}


ItemConfigTable::~ItemConfigTable() throw() {
}


void ItemConfigTable::__set_itemConfigMap(const std::map<int32_t, ItemConfig> & val) {
  this->itemConfigMap = val;
}

uint32_t ItemConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->itemConfigMap.clear();
            uint32_t _size62;
            ::apache::thrift::protocol::TType _ktype63;
            ::apache::thrift::protocol::TType _vtype64;
            xfer += iprot->readMapBegin(_ktype63, _vtype64, _size62);
            uint32_t _i66;
            for (_i66 = 0; _i66 < _size62; ++_i66)
            {
              int32_t _key67;
              xfer += iprot->readI32(_key67);
              ItemConfig& _val68 = this->itemConfigMap[_key67];
              xfer += _val68.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.itemConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemConfigTable");

  xfer += oprot->writeFieldBegin("itemConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->itemConfigMap.size()));
    std::map<int32_t, ItemConfig> ::const_iterator _iter69;
    for (_iter69 = this->itemConfigMap.begin(); _iter69 != this->itemConfigMap.end(); ++_iter69)
    {
      xfer += oprot->writeI32(_iter69->first);
      xfer += _iter69->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemConfigTable &a, ItemConfigTable &b) {
  using ::std::swap;
  swap(a.itemConfigMap, b.itemConfigMap);
  swap(a.__isset, b.__isset);
}

ItemConfigTable::ItemConfigTable(const ItemConfigTable& other70) {
  itemConfigMap = other70.itemConfigMap;
  __isset = other70.__isset;
}
ItemConfigTable& ItemConfigTable::operator=(const ItemConfigTable& other71) {
  itemConfigMap = other71.itemConfigMap;
  __isset = other71.__isset;
  return *this;
}
void ItemConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemConfigTable(";
  out << "itemConfigMap=" << to_string(itemConfigMap);
  out << ")";
}


BulletConfig::~BulletConfig() throw() {
}


void BulletConfig::__set_id(const int32_t val) {
  this->id = val;
}

void BulletConfig::__set_name(const std::string& val) {
  this->name = val;
}

void BulletConfig::__set_type(const int32_t val) {
  this->type = val;
}

void BulletConfig::__set_atk(const int32_t val) {
  this->atk = val;
}

void BulletConfig::__set_manaCost(const int32_t val) {
  this->manaCost = val;
}

void BulletConfig::__set_shootStrategy(const int32_t val) {
  this->shootStrategy = val;
}

void BulletConfig::__set_sourceName(const std::string& val) {
  this->sourceName = val;
}

void BulletConfig::__set_assetBundle(const std::string& val) {
  this->assetBundle = val;
}

void BulletConfig::__set_speed(const double val) {
  this->speed = val;
}

uint32_t BulletConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 40:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->atk);
          this->__isset.atk = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 50:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->manaCost);
          this->__isset.manaCost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 60:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->shootStrategy);
          this->__isset.shootStrategy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 70:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->sourceName);
          this->__isset.sourceName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 80:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->assetBundle);
          this->__isset.assetBundle = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 90:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->speed);
          this->__isset.speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulletConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulletConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("atk", ::apache::thrift::protocol::T_I32, 40);
  xfer += oprot->writeI32(this->atk);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("manaCost", ::apache::thrift::protocol::T_I32, 50);
  xfer += oprot->writeI32(this->manaCost);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("shootStrategy", ::apache::thrift::protocol::T_I32, 60);
  xfer += oprot->writeI32(this->shootStrategy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("sourceName", ::apache::thrift::protocol::T_STRING, 70);
  xfer += oprot->writeString(this->sourceName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("assetBundle", ::apache::thrift::protocol::T_STRING, 80);
  xfer += oprot->writeString(this->assetBundle);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed", ::apache::thrift::protocol::T_DOUBLE, 90);
  xfer += oprot->writeDouble(this->speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulletConfig &a, BulletConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.name, b.name);
  swap(a.type, b.type);
  swap(a.atk, b.atk);
  swap(a.manaCost, b.manaCost);
  swap(a.shootStrategy, b.shootStrategy);
  swap(a.sourceName, b.sourceName);
  swap(a.assetBundle, b.assetBundle);
  swap(a.speed, b.speed);
  swap(a.__isset, b.__isset);
}

BulletConfig::BulletConfig(const BulletConfig& other72) {
  id = other72.id;
  name = other72.name;
  type = other72.type;
  atk = other72.atk;
  manaCost = other72.manaCost;
  shootStrategy = other72.shootStrategy;
  sourceName = other72.sourceName;
  assetBundle = other72.assetBundle;
  speed = other72.speed;
  __isset = other72.__isset;
}
BulletConfig& BulletConfig::operator=(const BulletConfig& other73) {
  id = other73.id;
  name = other73.name;
  type = other73.type;
  atk = other73.atk;
  manaCost = other73.manaCost;
  shootStrategy = other73.shootStrategy;
  sourceName = other73.sourceName;
  assetBundle = other73.assetBundle;
  speed = other73.speed;
  __isset = other73.__isset;
  return *this;
}
void BulletConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulletConfig(";
  out << "id=" << to_string(id);
  out << ", " << "name=" << to_string(name);
  out << ", " << "type=" << to_string(type);
  out << ", " << "atk=" << to_string(atk);
  out << ", " << "manaCost=" << to_string(manaCost);
  out << ", " << "shootStrategy=" << to_string(shootStrategy);
  out << ", " << "sourceName=" << to_string(sourceName);
  out << ", " << "assetBundle=" << to_string(assetBundle);
  out << ", " << "speed=" << to_string(speed);
  out << ")";
}


BulletConfigTable::~BulletConfigTable() throw() {
}


void BulletConfigTable::__set_bulletConfigMap(const std::map<int32_t, BulletConfig> & val) {
  this->bulletConfigMap = val;
}

uint32_t BulletConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->bulletConfigMap.clear();
            uint32_t _size74;
            ::apache::thrift::protocol::TType _ktype75;
            ::apache::thrift::protocol::TType _vtype76;
            xfer += iprot->readMapBegin(_ktype75, _vtype76, _size74);
            uint32_t _i78;
            for (_i78 = 0; _i78 < _size74; ++_i78)
            {
              int32_t _key79;
              xfer += iprot->readI32(_key79);
              BulletConfig& _val80 = this->bulletConfigMap[_key79];
              xfer += _val80.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.bulletConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BulletConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BulletConfigTable");

  xfer += oprot->writeFieldBegin("bulletConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->bulletConfigMap.size()));
    std::map<int32_t, BulletConfig> ::const_iterator _iter81;
    for (_iter81 = this->bulletConfigMap.begin(); _iter81 != this->bulletConfigMap.end(); ++_iter81)
    {
      xfer += oprot->writeI32(_iter81->first);
      xfer += _iter81->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BulletConfigTable &a, BulletConfigTable &b) {
  using ::std::swap;
  swap(a.bulletConfigMap, b.bulletConfigMap);
  swap(a.__isset, b.__isset);
}

BulletConfigTable::BulletConfigTable(const BulletConfigTable& other82) {
  bulletConfigMap = other82.bulletConfigMap;
  __isset = other82.__isset;
}
BulletConfigTable& BulletConfigTable::operator=(const BulletConfigTable& other83) {
  bulletConfigMap = other83.bulletConfigMap;
  __isset = other83.__isset;
  return *this;
}
void BulletConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BulletConfigTable(";
  out << "bulletConfigMap=" << to_string(bulletConfigMap);
  out << ")";
}


SoundPath::~SoundPath() throw() {
}


void SoundPath::__set_type(const std::string& val) {
  this->type = val;
}

void SoundPath::__set_path(const std::string& val) {
  this->path = val;
}

uint32_t SoundPath::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->path);
          this->__isset.path = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SoundPath::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SoundPath");

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("path", ::apache::thrift::protocol::T_STRING, 20);
  xfer += oprot->writeString(this->path);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SoundPath &a, SoundPath &b) {
  using ::std::swap;
  swap(a.type, b.type);
  swap(a.path, b.path);
  swap(a.__isset, b.__isset);
}

SoundPath::SoundPath(const SoundPath& other84) {
  type = other84.type;
  path = other84.path;
  __isset = other84.__isset;
}
SoundPath& SoundPath::operator=(const SoundPath& other85) {
  type = other85.type;
  path = other85.path;
  __isset = other85.__isset;
  return *this;
}
void SoundPath::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SoundPath(";
  out << "type=" << to_string(type);
  out << ", " << "path=" << to_string(path);
  out << ")";
}


SoundPathMap::~SoundPathMap() throw() {
}


void SoundPathMap::__set_soundPathMap(const std::map<std::string, SoundPath> & val) {
  this->soundPathMap = val;
}

uint32_t SoundPathMap::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->soundPathMap.clear();
            uint32_t _size86;
            ::apache::thrift::protocol::TType _ktype87;
            ::apache::thrift::protocol::TType _vtype88;
            xfer += iprot->readMapBegin(_ktype87, _vtype88, _size86);
            uint32_t _i90;
            for (_i90 = 0; _i90 < _size86; ++_i90)
            {
              std::string _key91;
              xfer += iprot->readString(_key91);
              SoundPath& _val92 = this->soundPathMap[_key91];
              xfer += _val92.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.soundPathMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SoundPathMap::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SoundPathMap");

  xfer += oprot->writeFieldBegin("soundPathMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_STRING, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->soundPathMap.size()));
    std::map<std::string, SoundPath> ::const_iterator _iter93;
    for (_iter93 = this->soundPathMap.begin(); _iter93 != this->soundPathMap.end(); ++_iter93)
    {
      xfer += oprot->writeString(_iter93->first);
      xfer += _iter93->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SoundPathMap &a, SoundPathMap &b) {
  using ::std::swap;
  swap(a.soundPathMap, b.soundPathMap);
  swap(a.__isset, b.__isset);
}

SoundPathMap::SoundPathMap(const SoundPathMap& other94) {
  soundPathMap = other94.soundPathMap;
  __isset = other94.__isset;
}
SoundPathMap& SoundPathMap::operator=(const SoundPathMap& other95) {
  soundPathMap = other95.soundPathMap;
  __isset = other95.__isset;
  return *this;
}
void SoundPathMap::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SoundPathMap(";
  out << "soundPathMap=" << to_string(soundPathMap);
  out << ")";
}


ItemGeneratorConfig::~ItemGeneratorConfig() throw() {
}


void ItemGeneratorConfig::__set_id(const int32_t val) {
  this->id = val;
}

void ItemGeneratorConfig::__set_itemIds(const std::vector<int32_t> & val) {
  this->itemIds = val;
}

void ItemGeneratorConfig::__set_itemProbs(const std::vector<int32_t> & val) {
  this->itemProbs = val;
}

void ItemGeneratorConfig::__set_generateType(const int32_t val) {
  this->generateType = val;
}

uint32_t ItemGeneratorConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 20:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->itemIds.clear();
            uint32_t _size96;
            ::apache::thrift::protocol::TType _etype99;
            xfer += iprot->readListBegin(_etype99, _size96);
            this->itemIds.resize(_size96);
            uint32_t _i100;
            for (_i100 = 0; _i100 < _size96; ++_i100)
            {
              xfer += iprot->readI32(this->itemIds[_i100]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.itemIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 25:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->itemProbs.clear();
            uint32_t _size101;
            ::apache::thrift::protocol::TType _etype104;
            xfer += iprot->readListBegin(_etype104, _size101);
            this->itemProbs.resize(_size101);
            uint32_t _i105;
            for (_i105 = 0; _i105 < _size101; ++_i105)
            {
              xfer += iprot->readI32(this->itemProbs[_i105]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.itemProbs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 30:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->generateType);
          this->__isset.generateType = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemGeneratorConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemGeneratorConfig");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->id);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemIds", ::apache::thrift::protocol::T_LIST, 20);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->itemIds.size()));
    std::vector<int32_t> ::const_iterator _iter106;
    for (_iter106 = this->itemIds.begin(); _iter106 != this->itemIds.end(); ++_iter106)
    {
      xfer += oprot->writeI32((*_iter106));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("itemProbs", ::apache::thrift::protocol::T_LIST, 25);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->itemProbs.size()));
    std::vector<int32_t> ::const_iterator _iter107;
    for (_iter107 = this->itemProbs.begin(); _iter107 != this->itemProbs.end(); ++_iter107)
    {
      xfer += oprot->writeI32((*_iter107));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("generateType", ::apache::thrift::protocol::T_I32, 30);
  xfer += oprot->writeI32(this->generateType);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemGeneratorConfig &a, ItemGeneratorConfig &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.itemIds, b.itemIds);
  swap(a.itemProbs, b.itemProbs);
  swap(a.generateType, b.generateType);
  swap(a.__isset, b.__isset);
}

ItemGeneratorConfig::ItemGeneratorConfig(const ItemGeneratorConfig& other108) {
  id = other108.id;
  itemIds = other108.itemIds;
  itemProbs = other108.itemProbs;
  generateType = other108.generateType;
  __isset = other108.__isset;
}
ItemGeneratorConfig& ItemGeneratorConfig::operator=(const ItemGeneratorConfig& other109) {
  id = other109.id;
  itemIds = other109.itemIds;
  itemProbs = other109.itemProbs;
  generateType = other109.generateType;
  __isset = other109.__isset;
  return *this;
}
void ItemGeneratorConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemGeneratorConfig(";
  out << "id=" << to_string(id);
  out << ", " << "itemIds=" << to_string(itemIds);
  out << ", " << "itemProbs=" << to_string(itemProbs);
  out << ", " << "generateType=" << to_string(generateType);
  out << ")";
}


ItemGeneratorConfigTable::~ItemGeneratorConfigTable() throw() {
}


void ItemGeneratorConfigTable::__set_itemGeneratorConfigMap(const std::map<int32_t, ItemGeneratorConfig> & val) {
  this->itemGeneratorConfigMap = val;
}

uint32_t ItemGeneratorConfigTable::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_MAP) {
          {
            this->itemGeneratorConfigMap.clear();
            uint32_t _size110;
            ::apache::thrift::protocol::TType _ktype111;
            ::apache::thrift::protocol::TType _vtype112;
            xfer += iprot->readMapBegin(_ktype111, _vtype112, _size110);
            uint32_t _i114;
            for (_i114 = 0; _i114 < _size110; ++_i114)
            {
              int32_t _key115;
              xfer += iprot->readI32(_key115);
              ItemGeneratorConfig& _val116 = this->itemGeneratorConfigMap[_key115];
              xfer += _val116.read(iprot);
            }
            xfer += iprot->readMapEnd();
          }
          this->__isset.itemGeneratorConfigMap = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ItemGeneratorConfigTable::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ItemGeneratorConfigTable");

  xfer += oprot->writeFieldBegin("itemGeneratorConfigMap", ::apache::thrift::protocol::T_MAP, 10);
  {
    xfer += oprot->writeMapBegin(::apache::thrift::protocol::T_I32, ::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->itemGeneratorConfigMap.size()));
    std::map<int32_t, ItemGeneratorConfig> ::const_iterator _iter117;
    for (_iter117 = this->itemGeneratorConfigMap.begin(); _iter117 != this->itemGeneratorConfigMap.end(); ++_iter117)
    {
      xfer += oprot->writeI32(_iter117->first);
      xfer += _iter117->second.write(oprot);
    }
    xfer += oprot->writeMapEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ItemGeneratorConfigTable &a, ItemGeneratorConfigTable &b) {
  using ::std::swap;
  swap(a.itemGeneratorConfigMap, b.itemGeneratorConfigMap);
  swap(a.__isset, b.__isset);
}

ItemGeneratorConfigTable::ItemGeneratorConfigTable(const ItemGeneratorConfigTable& other118) {
  itemGeneratorConfigMap = other118.itemGeneratorConfigMap;
  __isset = other118.__isset;
}
ItemGeneratorConfigTable& ItemGeneratorConfigTable::operator=(const ItemGeneratorConfigTable& other119) {
  itemGeneratorConfigMap = other119.itemGeneratorConfigMap;
  __isset = other119.__isset;
  return *this;
}
void ItemGeneratorConfigTable::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ItemGeneratorConfigTable(";
  out << "itemGeneratorConfigMap=" << to_string(itemGeneratorConfigMap);
  out << ")";
}


VersionConfig::~VersionConfig() throw() {
}


void VersionConfig::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t VersionConfig::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t VersionConfig::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("VersionConfig");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 10);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(VersionConfig &a, VersionConfig &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

VersionConfig::VersionConfig(const VersionConfig& other120) {
  name = other120.name;
  __isset = other120.__isset;
}
VersionConfig& VersionConfig::operator=(const VersionConfig& other121) {
  name = other121.name;
  __isset = other121.__isset;
  return *this;
}
void VersionConfig::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "VersionConfig(";
  out << "name=" << to_string(name);
  out << ")";
}

} // namespace
